<!DOCTYPE html><html><head><title>SDL2 Documentation - MigrationGuide</title><meta charset="utf-8"><link rel="stylesheet" type="text/css" media="all" href="common.css"><link rel="stylesheet" type="text/css" media="screen" href="screen.css"></head><body><div id="sidebar">
<h1 id="wikinavigationheader">Wiki Navigation</h1>
<div class="sidepanel" id="sitenamelogo">
<div style="text-align:center"><a target="sdlpage" href="http://www.libsdl.org"><img src="logo.png" alt="SDL Logo"></a></div>
</div>
<ul id="wikiNavMenu">
<li class="sidepanel" id="sidebarSearch"><a href="index.html@MigrationGuide.html#" id="searchFormClose" onclick="return hideSearchForm()">
</a>Search Wiki
<form id="searchform" method="get" onsubmit="document.location.href='index.html@'+document.getElementById('searchinput').value+'.html';return false;">
<div>
<label style="display: none;" for="searchinput">Search:</label>
<input class="disabled" id="searchinput" name="value" value="" size="20" type="text">
<input id="titlesearch" name="titlesearch" value="Titles" style="visibility:hidden" type="submit">
</div>
</form>
</li><li>
</li><li id="sidewaysSearch"><a href="index.html@MigrationGuide.html#" onclick="showSearchForm()">Search &gt;</a></li> 
<li class="sidepanel">Navigation Links<ul id="navibar"><li class="wikilink current"><a href="index.html@FrontPage.html">FrontPage</a></li><li class="wikilink"><a href="index.html@Introduction.html">Introduction</a></li><li class="wikilink"><a href="index.html@Support.html">Support</a></li><li class="wikilink"><a href="index.html@CategoryAPI.html">API By Name</a></li><li class="wikilink"><a href="index.html@APIByCategory.html">API By Category</a></li></ul></li>
</ul>
</div><div class="sdl" id="content" lang="en"><span class="anchor" id=
"top"></span> <span class="anchor" id="line-1"></span><span class=
"anchor" id="line-2"></span><span class="anchor" id=
"line-3"></span><span class="anchor" id="line-4"></span>
<p class="line867"></p>
<h1 id="SDL_1.2_to_2.0_Migration_Guide">SDL 1.2 to 2.0 Migration
Guide</h1>
<span class="anchor" id="line-5"></span><span class="anchor" id=
"line-6"></span>
<p class="line867"></p>
<div class="table-of-contents">
<p class="table-of-contents-heading">Contents</p>
<ol>
<li><a href="index.html@MigrationGuide.html#SDL_1.2_to_2.0_Migration_Guide">SDL 1.2 to 2.0
Migration Guide</a>
<ol>
<li><a href="index.html@MigrationGuide.html#Translations">Translations</a></li>
<li><a href="index.html@MigrationGuide.html#Introduction">Introduction</a>
<ol>
<li><a href="index.html@MigrationGuide.html#Overview_of_new_features">Overview of new
features</a></li>
<li><a href="index.html@MigrationGuide.html#Looking_for_more_information">Looking for more
information</a></li>
</ol>
</li>
<li><a href="index.html@MigrationGuide.html#Moving_from_SDL_1.2_to_2.0">Moving from SDL 1.2 to
2.0</a>
<ol>
<li><a href="index.html@MigrationGuide.html#Some_general_truths">Some general truths</a></li>
<li><a href="index.html@MigrationGuide.html#Video">Video</a>
<ol>
<li><a href="index.html@MigrationGuide.html#Setting_up_a_game_with_the_new_video_API">Setting up
a game with the new video API</a></li>
<li><a href=
"index.html@MigrationGuide.html#If_your_game_just_wants_to_get_fully-rendered_frames_to_the_screen">
If your game just wants to get fully-rendered frames to the
screen</a></li>
<li><a href="index.html@MigrationGuide.html#If_your_game_wants_to_blit_surfaces_to_the_screen">If
your game wants to blit surfaces to the screen</a></li>
<li><a href="index.html@MigrationGuide.html#If_your_game_wants_to_do_both">If your game wants to
do both</a></li>
<li><a href="index.html@MigrationGuide.html#Other_Renderer_API_notes">Other Renderer API
notes</a></li>
</ol>
</li>
<li><a href="index.html@MigrationGuide.html#OpenGL">OpenGL</a></li>
<li><a href="index.html@MigrationGuide.html#Input">Input</a></li>
<li><a href="index.html@MigrationGuide.html#Events">Events</a></li>
<li><a href="index.html@MigrationGuide.html#Audio">Audio</a></li>
<li><a href="index.html@MigrationGuide.html#Joysticks">Joysticks</a></li>
<li><a href="index.html@MigrationGuide.html#Threads">Threads</a></li>
<li><a href="index.html@MigrationGuide.html#Audio_CDs">Audio CDs</a></li>
<li><a href="index.html@MigrationGuide.html#Dead_platforms">Dead platforms</a></li>
<li><a href="index.html@MigrationGuide.html#Mobile_platforms">Mobile platforms</a></li>
<li><a href="index.html@MigrationGuide.html#RWops">RWops</a></li>
<li><a href="index.html@MigrationGuide.html#Add-on_libraries">Add-on libraries</a></li>
<li><a href="index.html@MigrationGuide.html#Summary_of_some_renamed_or_replaced_things">Summary
of some renamed or replaced things</a></li>
<li><a href="index.html@MigrationGuide.html#Other_stuff">Other stuff</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</div>
<span class="anchor" id="line-7"></span><span class="anchor" id=
"line-8"></span>
<p class="line867"></p>
<h2 id="Translations">Translations</h2>
<span class="anchor" id="line-9"></span><span class="anchor" id=
"line-10"></span>
<ul>
<li>
<p class="line862">Une traduction de cette page par Developpez.com
est disponible <a class="http" href=
"http://jeux.developpez.com/tutoriels/sdl-2/guide-migration/">ici</a>.
<span class="anchor" id="line-11"></span></p>
</li>
<li>
<p class="line862">If you want to translate this page to other
languages, let Ryan know: <a class="mailto" href=
"mailto:icculus@icculus.org">icculus@icculus.org</a> <span class=
"anchor" id="line-12"></span><span class="anchor" id=
"line-13"></span></p>
</li>
</ul>
<p class="line867"></p>
<h2 id="Introduction">Introduction</h2>
<span class="anchor" id="line-14"></span><span class="anchor" id=
"line-15"></span>
<p class="line874">After many years in development, SDL 2.0 has
finally been released! <span class="anchor" id=
"line-16"></span><span class="anchor" id="line-17"></span></p>
<p class="line874">We are quite proud of it, and we'd like games
that are using SDL 1.2 to move up right away. As this can feel like
a daunting task, this document is a simple walkthrough of how to
migrate to the new library. We think you'll find it's not as hard
as you think, and often times, you'll be either replacing function
calls with direct equivalents or undoing some hacks in your code to
deal with 1.2 deficiencies. <span class="anchor" id=
"line-18"></span><span class="anchor" id="line-19"></span></p>
<p class="line862">We think you'll be very happy with SDL 2.0, both
for the new features and the better experience over SDL 1.2. This
document doesn't try to cover all the awesome new things in
SDL2--and there are many--but just the things you need to do to get
running <em>right now</em>. Once you've ported your code,
definitely check out the new stuff, you'll probably want to add
some of it to your application, too. <span class="anchor" id=
"line-20"></span><span class="anchor" id="line-21"></span></p>
<p class="line867"></p>
<h3 id="Overview_of_new_features">Overview of new features</h3>
<span class="anchor" id="line-22"></span>
<p class="line874">These are the most important new features in SDL
2.0: <span class="anchor" id="line-23"></span><span class="anchor"
id="line-24"></span></p>
<ul>
<li>Full 3D hardware acceleration <span class="anchor" id=
"line-25"></span></li>
<li>Support for OpenGL 3.0+ in various profiles (core,
compatibility, debug, robust, etc) <span class="anchor" id=
"line-26"></span></li>
<li>Support for OpenGL ES <span class="anchor" id=
"line-27"></span></li>
<li>Support for multiple windows <span class="anchor" id=
"line-28"></span></li>
<li>Support for multiple displays <span class="anchor" id=
"line-29"></span></li>
<li>Support for multiple audio devices <span class="anchor" id=
"line-30"></span></li>
<li>Android and iOS support <span class="anchor" id=
"line-31"></span></li>
<li>Simple 2D rendering API that can use Direct3D, OpenGL, OpenGL
ES, or software rendering behind the scenes <span class="anchor"
id="line-32"></span></li>
<li>Force Feedback available on Windows, Mac OS X and Linux
<span class="anchor" id="line-33"></span></li>
<li>XInput and XAudio2 support for Windows <span class="anchor" id=
"line-34"></span></li>
<li>Atomic operations <span class="anchor" id=
"line-35"></span></li>
<li>Power management (exposes battery life remaining, etc)
<span class="anchor" id="line-36"></span></li>
<li>Shaped windows <span class="anchor" id="line-37"></span></li>
<li>32-bit audio (int and float) <span class="anchor" id=
"line-38"></span></li>
<li>Simplified Game Controller API (the Joystick API is still here,
too!) <span class="anchor" id="line-39"></span></li>
<li>Touch support (multitouch, gestures, etc) <span class="anchor"
id="line-40"></span></li>
<li>Better fullscreen support <span class="anchor" id=
"line-41"></span></li>
<li>Better keyboard support (scancodes vs keycodes, etc).
<span class="anchor" id="line-42"></span></li>
<li>Message boxes <span class="anchor" id="line-43"></span></li>
<li>Clipboard support <span class="anchor" id=
"line-44"></span></li>
<li>Basic Drag'n'Drop support <span class="anchor" id=
"line-45"></span></li>
<li>Proper unicode input and IME support <span class="anchor" id=
"line-46"></span></li>
<li>
<p class="line891"><a href="index.html@CategoryAssertions.html">A really powerful
assert macro</a> <span class="anchor" id="line-47"></span></p>
</li>
<li>zlib license instead of LGPL. <span class="anchor" id=
"line-48"></span></li>
<li>Lots of old annoyances from 1.2 are gone <span class="anchor"
id="line-49"></span></li>
<li>Many other things! <span class="anchor" id=
"line-50"></span><span class="anchor" id="line-51"></span></li>
</ul>
<p class="line862">The <a href="index.html@Introduction.html">Introduction</a>
page has a more extensive listing about what features SDL offers in
overall (including old 1.2 features). <span class="anchor" id=
"line-52"></span><span class="anchor" id="line-53"></span></p>
<p class="line867"></p>
<h3 id="Looking_for_more_information">Looking for more
information</h3>
<span class="anchor" id="line-54"></span><span class="anchor" id=
"line-55"></span>
<p class="line874">The best place for information are: <span class=
"anchor" id="line-56"></span></p>
<ul>
<li>
<p class="line862">this wiki <img alt=":)" height="16" src="smile.png" title=":)" width="16">
<span class="anchor" id="line-57"></span></p>
</li>
<li>
<p class="line862">the tests included in SDL, in the <tt>test/</tt>
directory (<a class="http" href=
"http://hg.libsdl.org/SDL/file/default/test">browse online</a>)
<span class="anchor" id="line-58"></span></p>
</li>
<li>
<p class="line862">the SDL <a class="http" href=
"http://lists.libsdl.org/listinfo.cgi/sdl-libsdl.org">mailing
list</a> <span class="anchor" id="line-59"></span><span class=
"anchor" id="line-60"></span><span class="anchor" id=
"line-61"></span></p>
</li>
</ul>
<p class="line867"></p>
<h2 id="Moving_from_SDL_1.2_to_2.0">Moving from SDL 1.2 to 2.0</h2>
<span class="anchor" id="line-62"></span><span class="anchor" id=
"line-63"></span>
<p class="line867"></p>
<h3 id="Some_general_truths">Some general truths</h3>
<span class="anchor" id="line-64"></span><span class="anchor" id=
"line-65"></span>
<p class="line874">There is no compatibility layer built in to
SDL2. If an API changed for 2.0, we've changed or removed the old
functions where it makes sense. If you point your 1.2 program at
the 2.0 headers, it will probably fail to compile. This document
will try to talk you through the most important changes, and the
ones most likely to trip you up. <span class="anchor" id=
"line-66"></span><span class="anchor" id="line-67"></span></p>
<p class="line862">There's no SDL_main! Well, okay, there
<em>is</em>, and it now does what it was always meant to: be a
small piece of code that hides the difference between <tt class=
"backtick">main()</tt> and <tt class="backtick">WinMain()</tt> on
Windows. There's no initialization code in it, and it's completely
optional. This means you can use SDL without it taking over your
mainline, which is nice for plugins that use SDL, or scripting
languages with an SDL module. All the stuff you'd want the 1.2
SDL_main for is now in SDL_Init() where it belongs. <span class=
"anchor" id="line-68"></span><span class="anchor" id=
"line-69"></span></p>
<p class="line862">There's no SDL parachute anymore. What 1.2
called <tt class="backtick">SDL_INIT_NOPARACHUTE</tt> is a default
and only state now. This would cause problems if something other
than the main thread crashed, and it would interfere with apps
setting up their own signal/exception handlers. On the downside,
some platforms don't clean up fullscreen video well when crashing.
You should install your own crash handler, or call <a href="index.html@SDL_Quit.html">SDL_Quit</a>() in an <tt class="backtick">atexit()</tt>
function or whatnot if this is a concern. Note that on Unix
platforms, SDL still catches <tt class="backtick">SIGINT</tt> and
maps it to an <a href="index.html@SDL_EventType.html">SDL_QUIT</a> event.
<span class="anchor" id="line-70"></span><span class="anchor" id=
"line-71"></span><span class="anchor" id="line-72"></span></p>
<p class="line867"></p>
<h3 id="Video">Video</h3>
<span class="anchor" id="line-73"></span>
<p class="line867"></p>
<h4 id="Setting_up_a_game_with_the_new_video_API">Setting up a game
with the new video API</h4>
<span class="anchor" id="line-74"></span><span class="anchor" id=
"line-75"></span>
<p class="line874">The video API is the most dramatic change from
1.2. Needs have changed a great deal since SDL's API was designed
in the late 1990's. To deal with modern hardware and OS features,
we have almost completely replaced the old 1.2 video API.
<span class="anchor" id="line-76"></span><span class="anchor" id=
"line-77"></span></p>
<p class="line874">Don't worry, the new one is pretty great, and
once you understand what's changed, you're going to be very happy
with the new features it can bring to your 1.2 game. We'll discuss
those later. <span class="anchor" id="line-78"></span><span class=
"anchor" id="line-79"></span></p>
<p class="line874">The good news: if your game used OpenGL, you
probably don't have much to do: change a handful of function calls
to their SDL2 equivalents, and you're good to go. <span class=
"anchor" id="line-80"></span><span class="anchor" id=
"line-81"></span></p>
<p class="line874">For 2D graphics, SDL 1.2 offered a concept
called "surfaces," which were memory buffers of pixels. The screen
itself was a "surface," if you were doing 2D software rendering,
and we provided functions to copy ("blit") pixels between surfaces,
converting formats as necessary. You were almost always working on
the CPU in system RAM, not on the GPU in video memory. SDL 2.0
changes this; you almost always get hardware acceleration now, and
the API has changed to reflect this. <span class="anchor" id=
"line-82"></span><span class="anchor" id="line-83"></span></p>
<p class="line874">If you have a 2D game, chances are you've taken
one of three approaches to rendering. We'll go through them all,
but first, let's talk about introductory stuff. <span class=
"anchor" id="line-84"></span><span class="anchor" id=
"line-85"></span></p>
<p class="line862">Remember SDL_<a class="nonexistent" href="index.html@SetVideoMode.html">SetVideoMode</a>()? It's completely gone. SDL 2.0
allows you to have multiple windows, so the old function didn't
make sense any more. <span class="anchor" id=
"line-86"></span><span class="anchor" id="line-87"></span></p>
<p class="line874">So you might have had something like this:
<span class="anchor" id="line-88"></span><span class="anchor" id=
"line-89"></span></p>
<p class="line867"><span class="anchor" id=
"line-90"></span><span class="anchor" id=
"line-91"></span><span class="anchor" id="line-92"></span></p>
<div class="codearea" dir="ltr" lang="en"> 
<pre dir="ltr" id="CA-pygments_170" lang="en">
<span class="line"><span class=
"n">SDL_WM_SetCaption</span><span class="p">(</span><span class=
"s">"My Game Window"</span><span class="p">,</span> <span class=
"s">"game"</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_Surface</span> <span class="o">*</span><span class=
"n">screen</span> <span class="o">=</span> <span class=
"n">SDL_SetVideoMode</span><span class="p">(</span><span class=
"mi">640</span><span class="p">,</span> <span class=
"mi">480</span><span class="p">,</span> <span class=
"mi">0</span><span class="p">,</span> <span class=
"n">SDL_FULLSCREEN</span> <span class="o">|</span> <span class=
"n">SDL_OPENGL</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-93"></span><span class="anchor" id=
"line-94"></span>
<p class="line874">Which is now this: <span class="anchor" id=
"line-95"></span><span class="anchor" id="line-96"></span></p>
<p class="line867"><span class="anchor" id=
"line-97"></span><span class="anchor" id=
"line-98"></span><span class="anchor" id=
"line-99"></span><span class="anchor" id=
"line-100"></span><span class="anchor" id=
"line-101"></span><span class="anchor" id="line-102"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_171" lang="en">
<span class="line"><span class="n">SDL_Window</span> <span class=
"o">*</span><span class="n">screen</span> <span class=
"o">=</span> <span class="n">SDL_CreateWindow</span><span class=
"p">(</span><span class="s">"My Game Window"</span><span class=
"p">,</span>
</span><span class="line">                          <span class=
"n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
</span><span class="line">                          <span class=
"n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
</span><span class="line">                          <span class=
"mi">640</span><span class="p">,</span> <span class=
"mi">480</span><span class="p">,</span>
</span><span class="line">                          <span class=
"n">SDL_WINDOW_FULLSCREEN</span> <span class=
"o">|</span> <span class="n">SDL_WINDOW_OPENGL</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-103"></span><span class="anchor" id=
"line-104"></span>
<p class="line862">You can see that this maps pretty closely to
1.2. The difference is that you can have multiple windows (if you
want), and you can control them more. <tt class=
"backtick">SDL_WM_SetCaption</tt> is gone, because we want to allow
each window to have its own title (you can change it later with
<a href="index.html@SDL_SetWindowTitle.html">SDL_SetWindowTitle</a>()), and we
want to let you specify a window position (or, in this case, use
<strong>SDL_WINDOWPOS_UNDEFINED</strong> since we don't care where
the system places it. <strong>SDL_WINDOWPOS_CENTERED</strong> is
also a good choice). <span class="anchor" id=
"line-105"></span><span class="anchor" id="line-106"></span></p>
<p class="line874">Extra credit for letting users specify a display
for the window: SDL2 also allows you to manage systems with
multiple monitors. Don't worry about that right now, though.
<span class="anchor" id="line-107"></span><span class="anchor" id=
"line-108"></span></p>
<p class="line862">So now that your window is back on the screen,
let's talk strategy. SDL2 still has <a href="index.html@SDL_Surface.html">SDL_Surface</a>, but what you want, if possible, is
the new <a href="index.html@SDL_Texture.html">SDL_Texture</a>. Surfaces are always
in system RAM now, and are always operated on by the CPU, so we
want to get away from there. SDL2 has a new rendering API. It's
meant for use by simple 2D games, but most notably, it's meant to
get all that software rendering into video RAM and onto the GPU.
And even if you just want to use it to get your software renderer's
work to the screen, it brings some very nice benefits: if possible,
it will use OpenGL or Direct3D behind the scenes, which means
you'll get faster blits, a working Steam Overlay, and scaling for
free. <span class="anchor" id="line-109"></span><span class=
"anchor" id="line-110"></span></p>
<p class="line874">The setup looks like this. <span class="anchor"
id="line-111"></span><span class="anchor" id="line-112"></span></p>
<p class="line867"><tt class="backtick">SDL_SetVideoMode()</tt>
becomes <a href="index.html@SDL_CreateWindow.html">SDL_CreateWindow</a>(), as we
discussed before. But what do we put for the resolution? If your
game was hardcoded to 640x480, for example, you probably were
running into monitors that couldn't do that fullscreen resolution
at this point, and in windowed mode, your game probably looked like
an animated postage stamp on really high-end monitors. There's a
better solution in SDL2. <span class="anchor" id=
"line-113"></span><span class="anchor" id="line-114"></span></p>
<p class="line862">We don't call <tt class=
"backtick">SDL_ListModes()</tt> anymore. There's an equivalent in
SDL2 (call <a href="index.html@SDL_GetDisplayMode.html">SDL_GetDisplayMode</a>()
in a loop, <a href="index.html@SDL_GetNumDisplayModes.html">SDL_GetNumDisplayModes</a>() times), but
instead we're going to use a new feature called "fullscreen
desktop," which tells SDL "give me the whole screen and don't
change the resolution." For our hypothetical 640x480 game, it might
look like this: <span class="anchor" id=
"line-115"></span><span class="anchor" id="line-116"></span></p>
<p class="line867"><span class="anchor" id=
"line-117"></span><span class="anchor" id=
"line-118"></span><span class="anchor" id=
"line-119"></span><span class="anchor" id=
"line-120"></span><span class="anchor" id=
"line-121"></span><span class="anchor" id="line-122"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_172" lang="en">
<span class="line"><span class="n">SDL_Window</span> <span class=
"o">*</span><span class="n">sdlWindow</span> <span class=
"o">=</span> <span class="n">SDL_CreateWindow</span><span class=
"p">(</span><span class="n">title</span><span class="p">,</span>
</span><span class="line">                             <span class=
"n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
</span><span class="line">                             <span class=
"n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span>
</span><span class="line">                             <span class=
"mi">0</span><span class="p">,</span> <span class=
"mi">0</span><span class="p">,</span>
</span><span class="line">                             <span class=
"n">SDL_WINDOW_FULLSCREEN_DESKTOP</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-123"></span><span class="anchor" id=
"line-124"></span>
<p class="line874">Notice how we didn't specify 640 or
480...fullscreen desktop gives you the whole display and ignores
any dimensions you specify. The game window should come up
immediately, without waiting for the monitor to click into a new
resolution, and we'll be using the GPU to scale to the desktop
size, which tends to be faster and cleaner-looking than if an LCD
is faking a lower resolution. Added bonus: none of your background
windows are resizing themselves right now. <span class="anchor" id=
"line-125"></span><span class="anchor" id="line-126"></span></p>
<p class="line874">Now we need a rendering context. <span class=
"anchor" id="line-127"></span><span class="anchor" id=
"line-128"></span></p>
<p class="line867"><span class="anchor" id=
"line-129"></span><span class="anchor" id="line-130"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_173" lang="en">
<span class="line"><span class="n">SDL_Renderer</span> <span class=
"o">*</span><span class="n">renderer</span> <span class=
"o">=</span> <span class="n">SDL_CreateRenderer</span><span class=
"p">(</span><span class="n">sdlWindow</span><span class=
"p">,</span> <span class="o">-</span><span class=
"mi">1</span><span class="p">,</span> <span class=
"mi">0</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-131"></span><span class="anchor" id=
"line-132"></span>
<p class="line862">A renderer hides the details of how we draw into
the window. This might be using Direct3D, OpenGL, OpenGL ES, or
software surfaces behind the scenes, depending on what the system
offers; your code doesn't change, regardless of what SDL chooses
(although you <em>are</em> welcome to force one kind of renderer or
another). If you want to attempt to force sync-to-vblank to reduce
tearing, you can use <strong>SDL_RENDERER_PRESENTVSYNC</strong>
instead of zero for the third parameter. You shouldn't create a
window with the <strong>SDL_WINDOW_OPENGL</strong> flag here. If
<a href="index.html@SDL_CreateRenderer.html">SDL_CreateRenderer</a>() decides it
wants to use OpenGL, it'll update the window appropriately for you.
<span class="anchor" id="line-133"></span><span class="anchor" id=
"line-134"></span></p>
<p class="line862">Now that you understand how this works, you can
also do this all in one step with <a href="index.html@SDL_CreateWindowAndRenderer.html">SDL_CreateWindowAndRenderer</a>(),
if you don't want anything fancy: <span class="anchor" id=
"line-135"></span><span class="anchor" id="line-136"></span></p>
<p class="line867"><span class="anchor" id=
"line-137"></span><span class="anchor" id=
"line-138"></span><span class="anchor" id=
"line-139"></span><span class="anchor" id="line-140"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_174" lang="en">
<span class="line"><span class="n">SDL_Window</span> <span class=
"o">*</span><span class="n">sdlWindow</span><span class=
"p">;</span>
</span><span class="line"><span class=
"n">SDL_Renderer</span> <span class="o">*</span><span class=
"n">sdlRenderer</span><span class="p">;</span>
</span><span class="line"><span class=
"n">SDL_CreateWindowAndRenderer</span><span class=
"p">(</span><span class="mi">0</span><span class=
"p">,</span> <span class="mi">0</span><span class=
"p">,</span> <span class=
"n">SDL_WINDOW_FULLSCREEN_DESKTOP</span><span class=
"p">,</span> <span class="o">&amp;</span><span class=
"n">sdlWindow</span><span class="p">,</span> <span class=
"o">&amp;</span><span class="n">sdlRenderer</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-141"></span><span class="anchor" id=
"line-142"></span>
<p class="line874">Assuming these functions didn't fail (always
check for NULLs!), you are ready to start drawing to the screen.
Let's get started by clearing the screen to black. <span class=
"anchor" id="line-143"></span><span class="anchor" id=
"line-144"></span></p>
<p class="line867"><span class="anchor" id=
"line-145"></span><span class="anchor" id=
"line-146"></span><span class="anchor" id=
"line-147"></span><span class="anchor" id="line-148"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_175" lang="en">
<span class="line"><span class=
"n">SDL_SetRenderDrawColor</span><span class=
"p">(</span><span class="n">sdlRenderer</span><span class=
"p">,</span> <span class="mi">0</span><span class=
"p">,</span> <span class="mi">0</span><span class=
"p">,</span> <span class="mi">0</span><span class=
"p">,</span> <span class="mi">255</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderClear</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderPresent</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-149"></span><span class="anchor" id=
"line-150"></span>
<p class="line862">This works like you might think; draw in black
(r,g,b all zero, alpha full), clear the whole window, put the
cleared window on the screen. That's right, if you've been using
<tt class="backtick">SDL_UpdateRect()</tt> or <tt class=
"backtick">SDL_Flip()</tt> to get your bits to the screen, the
render API uses <a href="index.html@SDL_RenderPresent.html">SDL_RenderPresent</a>(). <span class="anchor"
id="line-151"></span><span class="anchor" id="line-152"></span></p>
<p class="line862">One more general thing to set up here. Since
we're using <strong>SDL_WINDOW_FULLSCREEN_DESKTOP</strong>, we
don't actually <em>know</em> how much screen we've got to draw to.
Fortunately, we don't have to know. One of the nice things about
1.2 is that you could say "I want a 640x480 window and I don't care
how you get it done," even if getting it done meant centering the
window in a larger resolution on behalf of your application.
<span class="anchor" id="line-153"></span><span class="anchor" id=
"line-154"></span></p>
<p class="line874">For 2.0, the render API lets you do this...
<span class="anchor" id="line-155"></span><span class="anchor" id=
"line-156"></span></p>
<p class="line867"><span class="anchor" id=
"line-157"></span><span class="anchor" id=
"line-158"></span><span class="anchor" id="line-159"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_176" lang="en">
<span class="line"><span class="n">SDL_SetHint</span><span class=
"p">(</span><span class=
"n">SDL_HINT_RENDER_SCALE_QUALITY</span><span class=
"p">,</span> <span class="s">"linear"</span><span class=
"p">);</span>  <span class=
"c1">// make the scaled rendering look smoother.</span>
</span><span class="line"><span class=
"n">SDL_RenderSetLogicalSize</span><span class=
"p">(</span><span class="n">sdlRenderer</span><span class=
"p">,</span> <span class="mi">640</span><span class=
"p">,</span> <span class="mi">480</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-160"></span><span class="anchor" id=
"line-161"></span>
<p class="line874">...and it will do the right thing for you. This
is nice in that you can change the logical rendering size to
achieve various effects, but the primary use is this: instead of
trying to make the system work with your rendering size, we can now
make your rendering size work with the system. On my 1920x1200
monitor, this app thinks it's talking to a 640x480 resolution now,
but SDL is using the GPU to scale it up to use all those pixels.
Note that 640x480 and 1920x1200 aren't the same aspect ratio: SDL
takes care of that, too, scaling as much as possible and
letterboxing the difference. <span class="anchor" id=
"line-162"></span><span class="anchor" id="line-163"></span></p>
<p class="line874">Now we're ready to start drawing for real.
<span class="anchor" id="line-164"></span><span class="anchor" id=
"line-165"></span><span class="anchor" id="line-166"></span></p>
<p class="line867"></p>
<h4 id=
"If_your_game_just_wants_to_get_fully-rendered_frames_to_the_screen">
If your game just wants to get fully-rendered frames to the
screen</h4>
<span class="anchor" id="line-167"></span><span class="anchor" id=
"line-168"></span>
<p class="line862">A special case for old school software rendered
games: the application wants to draw every pixel itself and get
that final set of pixels to the screen efficiently in one big blit.
An example of a game like this is <em>Doom</em>, or <em>Duke Nukem
3D</em>, or many others. <span class="anchor" id=
"line-169"></span><span class="anchor" id="line-170"></span></p>
<p class="line874">For this, you're going to want a single
SDL_Texture that will represent the screen. Let's create one now
for our 640x480 game: <span class="anchor" id=
"line-171"></span><span class="anchor" id="line-172"></span></p>
<p class="line867"><span class="anchor" id=
"line-173"></span><span class="anchor" id=
"line-174"></span><span class="anchor" id=
"line-175"></span><span class="anchor" id=
"line-176"></span><span class="anchor" id="line-177"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_177" lang="en">
<span class="line"><span class="n">sdlTexture</span> <span class=
"o">=</span> <span class="n">SDL_CreateTexture</span><span class=
"p">(</span><span class="n">sdlRenderer</span><span class=
"p">,</span>
</span><span class=
"line">                               <span class=
"n">SDL_PIXELFORMAT_ARGB8888</span><span class="p">,</span>
</span><span class=
"line">                               <span class=
"n">SDL_TEXTUREACCESS_STREAMING</span><span class="p">,</span>
</span><span class=
"line">                               <span class=
"mi">640</span><span class="p">,</span> <span class=
"mi">480</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-178"></span><span class="anchor" id=
"line-179"></span>
<p class="line862">This represents a texture on the GPU. The
gameplan is to finish each frame by uploading pixels to this
texture, drawing the texture to the window, and flipping this
drawing onto the screen.
<strong>SDL_TEXTUREACCESS_STREAMING</strong> tells SDL that this
texture's contents are going to change frequently. <span class=
"anchor" id="line-180"></span><span class="anchor" id=
"line-181"></span></p>
<p class="line862">Before you probably had an <a href="index.html@SDL_Surface.html">SDL_Surface</a> for the screen that your app drew
into, then called <tt class="backtick">SDL_Flip()</tt> to put to
the screen. Now you can create an <a href="index.html@SDL_Surface.html">SDL_Surface</a> that is always in RAM instead of
using the one you would have gotten from <tt class=
"backtick">SDL_SetVideoMode()</tt>, or just malloc() a block of
pixels to write into. Ideally you write to a buffer of RGBA pixels,
but if you need to do a conversion, that's okay too. <span class=
"anchor" id="line-182"></span><span class="anchor" id=
"line-183"></span></p>
<p class="line867"><span class="anchor" id=
"line-184"></span><span class="anchor" id="line-185"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_178" lang="en">
<span class="line"><span class="k">extern</span> <span class=
"n">Uint32</span> <span class="o">*</span><span class=
"n">myPixels</span><span class="p">;</span>  <span class=
"c1">// maybe this is a surface-&gt;pixels, or a malloc()'d buffer, or whatever.</span>
</span>
</pre></div>
<span class="anchor" id="line-186"></span><span class="anchor" id=
"line-187"></span>
<p class="line874">At the end of the frame, we want to upload to
the texture like this: <span class="anchor" id=
"line-188"></span><span class="anchor" id="line-189"></span></p>
<p class="line867"><span class="anchor" id=
"line-190"></span><span class="anchor" id="line-191"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_179" lang="en">
<span class="line"><span class=
"n">SDL_UpdateTexture</span><span class="p">(</span><span class=
"n">sdlTexture</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">,</span> <span class=
"n">myPixels</span><span class="p">,</span> <span class=
"mi">640</span> <span class="o">*</span> <span class=
"k">sizeof</span> <span class="p">(</span><span class=
"n">Uint32</span><span class="p">));</span>
</span>
</pre></div>
<span class="anchor" id="line-192"></span><span class="anchor" id=
"line-193"></span>
<p class="line874">This will upload your pixels to GPU memory. That
NULL can be a subregion if you want to mess around with dirty
rectangles, but chances are modern hardware can just swallow the
whole framebuffer without much trouble. The final argument is the
pitch--the number of bytes from the start of one row to the
next--and since we have a linear RGBA buffer in this example, it's
just 640 times 4 (r,g,b,a). <span class="anchor" id=
"line-194"></span><span class="anchor" id="line-195"></span></p>
<p class="line874">Now get that texture to the screen: <span class=
"anchor" id="line-196"></span><span class="anchor" id=
"line-197"></span></p>
<p class="line867"><span class="anchor" id=
"line-198"></span><span class="anchor" id=
"line-199"></span><span class="anchor" id=
"line-200"></span><span class="anchor" id="line-201"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_180" lang="en">
<span class="line"><span class=
"n">SDL_RenderClear</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderCopy</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">,</span> <span class=
"n">sdlTexture</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderPresent</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-202"></span><span class="anchor" id=
"line-203"></span>
<p class="line862">That's all. <a href="index.html@SDL_RenderClear.html">SDL_RenderClear</a>() wipes out the existing
video framebuffer (in case, say, the Steam Overlay wrote over it
last frame), <a href="index.html@SDL_RenderCopy.html">SDL_RenderCopy</a>() moves
the texture's contents to the video framebuffer (and thanks to
<a href="index.html@SDL_RenderSetLogicalSize.html">SDL_RenderSetLogicalSize</a>(),
it will be scaled/centered as if the monitor was 640x480), and
<a href="index.html@SDL_RenderPresent.html">SDL_RenderPresent</a>() puts it on the
screen. <span class="anchor" id="line-204"></span><span class=
"anchor" id="line-205"></span><span class="anchor" id=
"line-206"></span></p>
<p class="line867"></p>
<h4 id="If_your_game_wants_to_blit_surfaces_to_the_screen">If your
game wants to blit surfaces to the screen</h4>
<span class="anchor" id="line-207"></span><span class="anchor" id=
"line-208"></span>
<p class="line862">This scenario has your SDL 1.2 game loading a
bunch of graphics from disk into a bunch of <a href="index.html@SDL_Surface.html">SDL_Surfaces</a>, possibly trying to get them into
video RAM with <tt class="backtick">SDL_HWSURFACE</tt>. You load
these once, and you blit them over and over to the framebuffer as
necessary, but otherwise they never change. A simple 2D platformer
might do this. If you tend to think of your surfaces as "sprites,"
and not buffers of pixels, then this is probably you. <span class=
"anchor" id="line-209"></span><span class="anchor" id=
"line-210"></span></p>
<p class="line874">You can build individual textures (surfaces that
live in GPU memory) like we did for that one big texture:
<span class="anchor" id="line-211"></span><span class="anchor" id=
"line-212"></span></p>
<p class="line867"><span class="anchor" id=
"line-213"></span><span class="anchor" id=
"line-214"></span><span class="anchor" id=
"line-215"></span><span class="anchor" id=
"line-216"></span><span class="anchor" id="line-217"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_181" lang="en">
<span class="line"><span class="n">sdlTexture</span> <span class=
"o">=</span> <span class="n">SDL_CreateTexture</span><span class=
"p">(</span><span class="n">sdlRenderer</span><span class=
"p">,</span>
</span><span class=
"line">                               <span class=
"n">SDL_PIXELFORMAT_ARGB8888</span><span class="p">,</span>
</span><span class=
"line">                               <span class=
"n">SDL_TEXTUREACCESS_STATIC</span><span class="p">,</span>
</span><span class=
"line">                               <span class=
"n">myWidth</span><span class="p">,</span> <span class=
"n">myHeight</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-218"></span><span class="anchor" id=
"line-219"></span>
<p class="line862">Which does what you'd expect. We use
<strong>SDL_TEXTUREACCESS_STATIC</strong>, because we're going to
upload our pixels once instead of over and over. But a more
convenient solution might be: <span class="anchor" id=
"line-220"></span><span class="anchor" id="line-221"></span></p>
<p class="line867"><span class="anchor" id=
"line-222"></span><span class="anchor" id="line-223"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_182" lang="en">
<span class="line"><span class="n">sdlTexture</span> <span class=
"o">=</span> <span class=
"n">SDL_CreateTextureFromSurface</span><span class=
"p">(</span><span class="n">sdlRenderer</span><span class=
"p">,</span> <span class="n">mySurface</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-224"></span><span class="anchor" id=
"line-225"></span>
<p class="line862">Use this, and you load your <a href="index.html@SDL_Surface.html">SDL_Surface</a> as usual, but then at the end you
make a texture out of it. Once you have an <a href="index.html@SDL_Texture.html">SDL_Texture</a>, you can free the original surface.
<span class="anchor" id="line-226"></span><span class="anchor" id=
"line-227"></span></p>
<p class="line862">At this point, your 1.2 game had a bunch of
<a href="index.html@SDL_Surface.html">SDL_Surfaces</a>, which it would <a href="index.html@SDL_BlitSurface.html">SDL_BlitSurface</a>() to the screen surface to
compose the final framebuffer, and eventually <tt class=
"backtick">SDL_Flip()</tt> to the screen. For SDL 2.0, you have a
bunch of <a href="index.html@SDL_Texture.html">SDL_Textures</a>, that you will
<a href="index.html@SDL_RenderCopy.html">SDL_RenderCopy</a>() to your Renderer to
compose the final framebuffer, and eventually <a href="index.html@SDL_RenderPresent.html">SDL_RenderPresent</a>() to the screen. It's
that simple. If these textures never need modification, you might
find your framerate has just gone through the roof, too.
<span class="anchor" id="line-228"></span><span class="anchor" id=
"line-229"></span><span class="anchor" id="line-230"></span></p>
<p class="line867"></p>
<h4 id="If_your_game_wants_to_do_both">If your game wants to do
both</h4>
<span class="anchor" id="line-231"></span><span class="anchor" id=
"line-232"></span>
<p class="line862">Things get slightly more complicated if you want
to blit surfaces <em>and</em> modify individual pixels in the
framebuffer. Round trips--reading data back from textures--can be
painfully expensive; generally you want to be pushing data in one
direction always. You are probably best off, in this case, keeping
everything in software until the final push to the screen, so we'll
combine the two previous techniques. <span class="anchor" id=
"line-233"></span><span class="anchor" id="line-234"></span></p>
<p class="line862">The good news: the 1.2 <a href="index.html@SDL_Surface.html">SDL_Surface</a> API mostly still exists. So change
your screen surface from this: <span class="anchor" id=
"line-235"></span><span class="anchor" id="line-236"></span></p>
<p class="line867"><span class="anchor" id=
"line-237"></span><span class="anchor" id="line-238"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_183" lang="en">
<span class="line"><span class="n">SDL_Surface</span> <span class=
"o">*</span><span class="n">screen</span> <span class=
"o">=</span> <span class="n">SDL_SetVideoMode</span><span class=
"p">(</span><span class="mi">640</span><span class=
"p">,</span> <span class="mi">480</span><span class=
"p">,</span> <span class="mi">32</span><span class=
"p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-239"></span><span class="anchor" id=
"line-240"></span>
<p class="line874">...to this... <span class="anchor" id=
"line-241"></span><span class="anchor" id="line-242"></span></p>
<p class="line867"><span class="anchor" id=
"line-243"></span><span class="anchor" id=
"line-244"></span><span class="anchor" id=
"line-245"></span><span class="anchor" id=
"line-246"></span><span class="anchor" id=
"line-247"></span><span class="anchor" id=
"line-248"></span><span class="anchor" id=
"line-249"></span><span class="anchor" id=
"line-250"></span><span class="anchor" id=
"line-251"></span><span class="anchor" id=
"line-252"></span><span class="anchor" id="line-253"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_184" lang="en">
<span class="line"><span class=
"c1">// if all this hex scares you, check out SDL_PixelFormatEnumToMasks()!</span>
</span><span class="line"><span class=
"n">SDL_Surface</span> <span class="o">*</span><span class=
"n">screen</span> <span class="o">=</span> <span class=
"n">SDL_CreateRGBSurface</span><span class="p">(</span><span class=
"mi">0</span><span class="p">,</span> <span class=
"mi">640</span><span class="p">,</span> <span class=
"mi">480</span><span class="p">,</span> <span class=
"mi">32</span><span class="p">,</span>
</span><span class=
"line">                                        <span class=
"mh">0x00FF000</span><span class="p">,</span>
</span><span class=
"line">                                        <span class=
"mh">0x0000FF00</span><span class="p">,</span>
</span><span class=
"line">                                        <span class=
"mh">0x000000FF</span><span class="p">,</span>
</span><span class=
"line">                                        <span class=
"mh">0xFF000000</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_Texture</span> <span class="o">*</span><span class=
"n">sdlTexture</span> <span class="o">=</span> <span class=
"n">SDL_CreateTexture</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">,</span>
</span><span class=
"line">                                            <span class=
"n">SDL_PIXELFORMAT_ARGB8888</span><span class="p">,</span>
</span><span class=
"line">                                            <span class=
"n">SDL_TEXTUREACCESS_STREAMING</span><span class="p">,</span>
</span><span class=
"line">                                            <span class=
"mi">640</span><span class="p">,</span> <span class=
"mi">480</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-254"></span><span class="anchor" id=
"line-255"></span>
<p class="line862">...and continue blitting things around and
tweaking pixels as before, composing your final framebuffer into
this <a href="index.html@SDL_Surface.html">SDL_Surface</a>. Once you're ready to
get those pixels on the screen, you do this just like in our first
scenario: <span class="anchor" id="line-256"></span><span class=
"anchor" id="line-257"></span></p>
<p class="line867"><span class="anchor" id=
"line-258"></span><span class="anchor" id=
"line-259"></span><span class="anchor" id=
"line-260"></span><span class="anchor" id=
"line-261"></span><span class="anchor" id="line-262"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_185" lang="en">
<span class="line"><span class=
"n">SDL_UpdateTexture</span><span class="p">(</span><span class=
"n">sdlTexture</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">,</span> <span class=
"n">screen</span><span class="o">-&gt;</span><span class=
"n">pixels</span><span class="p">,</span> <span class=
"n">screen</span><span class="o">-&gt;</span><span class=
"n">pitch</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderClear</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderCopy</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">,</span> <span class=
"n">sdlTexture</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">,</span> <span class=
"nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_RenderPresent</span><span class="p">(</span><span class=
"n">sdlRenderer</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-263"></span><span class="anchor" id=
"line-264"></span>
<p class="line862">Note that texture creation may be both expensive
and a limited resource: don't call <a href="index.html@SDL_CreateTextureFromSurface.html">SDL_CreateTextureFromSurface</a>()
every frame. Set up one texture and one surface and update the
former from the latter. <span class="anchor" id=
"line-265"></span><span class="anchor" id="line-266"></span></p>
<p class="line874">There are more features to the Render API, some
of which may be able to replace your application's code: scaling,
line drawing, etc. If you are reading this section because you have
simple needs beyond blitting surfaces, you might be able to stop
poking individual pixels and move everything onto the GPU, which
will give your program a significant speed boost and probably
simplify your code greatly. <span class="anchor" id=
"line-267"></span><span class="anchor" id="line-268"></span></p>
<p class="line867"></p>
<h4 id="Other_Renderer_API_notes">Other Renderer API notes</h4>
<span class="anchor" id="line-269"></span><span class="anchor" id=
"line-270"></span>
<p class="line874">You can do some simple effects with the render
API without having to get down into direct pixel manipulation. Some
of these were available on 1.2 surfaces. <span class="anchor" id=
"line-271"></span><span class="anchor" id="line-272"></span></p>
<ul>
<li>
<p class="line862">Color alpha: <a href="index.html@SDL_Color.html">SDL_Color</a>
now contains a fourth, <strong>alpha</strong> component. Your 1.2
code that deals with SDL_Colors might be not copying/setting that
value (which was named <tt class="backtick">unused</tt>). In 2.0,
you should. <span class="anchor" id="line-273"></span></p>
</li>
<li>
<p class="line862">Alpha blending: use <a href="index.html@SDL_SetSurfaceAlphaMod.html">SDL_SetSurfaceAlphaMod</a> and <a href="index.html@SDL_SetTextureAlphaMod.html">SDL_SetTextureAlphaMod</a> instead of
<tt class="backtick">SDL_SetAlpha()</tt>. Alpha-blending on
surfaces can be disabled via <a href="index.html@SDL_SetSurfaceBlendMode.html">SDL_SetSurfaceBlendMode</a>() and on
textures with <a href="index.html@SDL_SetTextureBlendMode.html">SDL_SetTextureBlendMode</a>().
<span class="anchor" id="line-274"></span></p>
</li>
<li>
<p class="line862">Colorkey: When calling <a href="index.html@SDL_SetColorKey.html">SDL_SetColorKey</a>(), you should pass
<tt class="backtick">SDL_TRUE</tt> instead of <tt class=
"backtick">SDL_SRCCOLORKEY</tt>. <span class="anchor" id=
"line-275"></span></p>
</li>
<li>
<p class="line862">Color modulation: Some renderers now support a
global color alteration
(<tt>srcC&nbsp;=&nbsp;srcC&nbsp;*&nbsp;color</tt>), check <a href="index.html@SDL_SetTextureColorMod.html">SDL_SetTextureColorMod</a>() for details.
<span class="anchor" id="line-276"></span><span class="anchor" id=
"line-277"></span></p>
</li>
</ul>
<p class="line867"></p>
<h3 id="OpenGL">OpenGL</h3>
<span class="anchor" id="line-278"></span><span class="anchor" id=
"line-279"></span>
<p class="line862">If you were already using OpenGL directly, your
migration is pretty simple. Change your <tt class=
"backtick">SDL_SetVideoMode()</tt> call to <a href="index.html@SDL_CreateWindow.html">SDL_CreateWindow</a>() followed by <a href="index.html@SDL_GL_CreateContext.html">SDL_GL_CreateContext</a>(), and your
<tt class="backtick">SDL_GL_SwapBuffers()</tt> call to <a href="index.html@SDL_GL_SwapWindow.html">SDL_GL_SwapWindow</a>(window). All the actual
calls into the GL are exactly the same. <span class="anchor" id=
"line-280"></span><span class="anchor" id="line-281"></span></p>
<p class="line862">If you had used <a href="index.html@SDL_GL_SetAttribute.html">SDL_GL_SetAttribute</a>(SDL_GL_SWAP_CONTROL,
x), this has changed. There is now an <a href="index.html@SDL_GL_SetSwapInterval.html">SDL_GL_SetSwapInterval</a>(x) call, so
you can change this on an existing GL context. <span class="anchor"
id="line-282"></span><span class="anchor" id="line-283"></span></p>
<p class="line862">Note that SDL 2.0 can toggle windowed/fullscreen
and back with OpenGL windows without losing the GL context
(hooray!). Use <a href="index.html@SDL_SetWindowFullscreen.html">SDL_SetWindowFullscreen</a>() for this.
<span class="anchor" id="line-284"></span><span class="anchor" id=
"line-285"></span><span class="anchor" id="line-286"></span></p>
<p class="line867"></p>
<h3 id="Input">Input</h3>
<span class="anchor" id="line-287"></span><span class="anchor" id=
"line-288"></span>
<p class="line874">The good news is that SDL 2.0 has made Unicode
input usable. The bad news is that it will take some minor changes
to your application. <span class="anchor" id=
"line-289"></span><span class="anchor" id="line-290"></span></p>
<p class="line862">In 1.2, many applications that only cared about
US English still called <tt class=
"backtick">SDL_EnableUNICODE(1)</tt>, because it was useful to get
the character that was associated with a keypress. This didn't work
well once you got outside of English, and it really didn't work
<em>at all</em> once you got to Asian languages. <span class=
"anchor" id="line-291"></span><span class="anchor" id=
"line-292"></span></p>
<p class="line874">It turns out, i18n is hard. <span class="anchor"
id="line-293"></span><span class="anchor" id="line-294"></span></p>
<p class="line862">SDL changed this. <tt class=
"backtick">SDL_EnableUNICODE()</tt> is gone, and so is <a href="index.html@SDL_Keysym.html">SDL_Keysym</a>'s <tt class="backtick">unicode</tt>
field. You no longer get character input from <a href="index.html@SDL_EventType.html">SDL_KEYDOWN</a> events. Use <a href="index.html@SDL_EventType.html">SDL_KEYDOWN</a> to treat the keyboard like a
101-button joystick now. Text input comes from somewhere else.
<span class="anchor" id="line-295"></span><span class="anchor" id=
"line-296"></span></p>
<p class="line862">The new event is <a href="index.html@SDL_EventType.html">SDL_TEXTINPUT</a>. This is triggered whenever
there's new text entered by the user. Note that this text might be
coming from keypresses, or it might be coming from some sort of IME
(which is a fancy way of entering complicated, multi-character
text). This event returns entire strings, which might be one char
long, or several codepoints of multi-character data. This string is
always in UTF-8 encoding. <span class="anchor" id=
"line-297"></span><span class="anchor" id="line-298"></span></p>
<p class="line862">If all you care about is whether the user
pressed a certain key, that's still <a href="index.html@SDL_EventType.html">SDL_KEYDOWN</a>, but we've split this system into
two pieces since 1.2: keycodes and scancodes. <span class="anchor"
id="line-299"></span><span class="anchor" id="line-300"></span></p>
<p class="line874">Scancodes are meant to be layout-independent.
Think of this as "the user pressed the Q key as it would be on a US
QWERTY keyboard" regardless of whether this is actually a European
keyboard or a Dvorak keyboard or whatever. The scancode is always
the same key position. <span class="anchor" id=
"line-301"></span><span class="anchor" id="line-302"></span></p>
<p class="line874">Keycodes are meant to be layout-dependent. Think
of this as "the user pressed the key that is labelled 'Q' on his
specific keyboard." <span class="anchor" id=
"line-303"></span><span class="anchor" id="line-304"></span></p>
<p class="line874">In example, if you pressed the key that's two
keys to the right of CAPS LOCK on a US QWERTY keyboard, it'll
report a scancode of SDL_SCANCODE_S and a keycode of SDLK_S. The
same key on a Dvorak keyboard, will report a scancode of
SDL_SCANCODE_S and a keycode of SDLK_O. <span class="anchor" id=
"line-305"></span><span class="anchor" id="line-306"></span></p>
<p class="line862">Note that both keycodes and scancodes are now 32
bits, and use a wide range of numbers. There's no <tt class=
"backtick">SDLK_LAST</tt> anymore. If your program had a lookup
table of SDLK_LAST elements, to map between SDL keys and whatever
your application wanted internally, that's no longer feasible. Use
a hash table instead. A <tt class="backtick">std::map</tt> will do.
If you're mapping scancodes instead of keycodes, there's
<strong>SDL_NUM_SCANCODES</strong>, which you can use for array
bounds. It's 512 at the moment. <span class="anchor" id=
"line-307"></span><span class="anchor" id="line-308"></span></p>
<p class="line867"><tt class="backtick">SDLMod</tt> is now <a href="index.html@SDL_Keymod.html">SDL_Keymod</a> and its "META" keys (the "Windows"
keys) are now called the "GUI" keys. <span class="anchor" id=
"line-309"></span><span class="anchor" id="line-310"></span></p>
<p class="line867"><tt class="backtick">SDL_GetKeyState()</tt> has
been renamed to <a href="index.html@SDL_GetKeyboardState.html">SDL_GetKeyboardState</a>(). The returned
array should now be indexed by SDL_SCANCODE_* values (see <a href="index.html@SDL_Scancode.html">SDL_Scancode</a>) instead of <a href="index.html@SDL_Keysym.html">SDL_Keysym</a> values. <span class="anchor" id=
"line-311"></span><span class="anchor" id="line-312"></span></p>
<p class="line874">Now, for mouse input. <span class="anchor" id=
"line-313"></span><span class="anchor" id="line-314"></span></p>
<p class="line862">The first change, simply enough, is that the
mousewheel is no longer a button. This was a mistake of history,
and we've corrected it in SDL 2.0. Look for <a href="index.html@SDL_EventType.html">SDL_MOUSEWHEEL</a> events. We support both
vertical and horizontal wheels, and some platforms can treat
two-finger scrolling on a trackpad as wheel input, too. You will no
longer receive <a href="index.html@SDL_EventType.html">SDL_BUTTONDOWN</a> events
for mouse wheels, and buttons 4 and 5 are real mouse buttons now.
<span class="anchor" id="line-315"></span><span class="anchor" id=
"line-316"></span></p>
<p class="line874">If your game needed to roll the mouse in one
direction forever, for example to let a player in an FPS to spin
around without the mouse hitting the edge of the screen and
stopping, you probably hid the mouse cursor and grabbed input:
<span class="anchor" id="line-317"></span><span class="anchor" id=
"line-318"></span></p>
<p class="line867"><span class="anchor" id=
"line-319"></span><span class="anchor" id=
"line-320"></span><span class="anchor" id="line-321"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_186" lang="en">
<span class="line"><span class=
"n">SDL_ShowCursor</span><span class="p">(</span><span class=
"mi">0</span><span class="p">);</span>
</span><span class="line"><span class=
"n">SDL_WM_GrabInput</span><span class="p">(</span><span class=
"n">SDL_GRAB_ON</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-322"></span><span class="anchor" id=
"line-323"></span>
<p class="line874">In SDL2, this works slightly differently. You
call... <span class="anchor" id="line-324"></span><span class=
"anchor" id="line-325"></span></p>
<p class="line867"><span class="anchor" id=
"line-326"></span><span class="anchor" id="line-327"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_187" lang="en">
<span class="line"><span class=
"n">SDL_SetRelativeMouseMode</span><span class=
"p">(</span><span class="n">SDL_TRUE</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-328"></span><span class="anchor" id=
"line-329"></span>
<p class="line874">...and SDL does the rest. <span class="anchor"
id="line-330"></span><span class="anchor" id=
"line-331"></span><span class="anchor" id="line-332"></span></p>
<p class="line867"></p>
<h3 id="Events">Events</h3>
<span class="anchor" id="line-333"></span><span class="anchor" id=
"line-334"></span>
<p class="line867"><a href="index.html@SDL_PushEvent.html">SDL_PushEvent</a>() now
returns <tt class="backtick">1</tt> on success instead of
<tt class="backtick">0</tt>. <span class="anchor" id=
"line-335"></span><span class="anchor" id="line-336"></span></p>
<p class="line874">Events mask are now specified using ranges:
<span class="anchor" id="line-337"></span><span class="anchor" id=
"line-338"></span></p>
<p class="line867"><span class="anchor" id=
"line-339"></span><span class="anchor" id="line-340"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_188" lang="en">
<span class="line"><span class=
"n">SDL_PeepEvents</span><span class="p">(</span><span class=
"o">&amp;</span><span class="n">event</span><span class=
"p">,</span> <span class="mi">1</span><span class=
"p">,</span> <span class="n">SDL_GETEVENT</span><span class=
"p">,</span> <span class="n">SDL_EVENTMASK</span><span class=
"p">(</span><span class="n">SDL_MOUSEBUTTONDOWN</span><span class=
"p">));</span>
</span>
</pre></div>
<span class="anchor" id="line-341"></span><span class="anchor" id=
"line-342"></span>
<p class="line874">becomes: <span class="anchor" id=
"line-343"></span><span class="anchor" id="line-344"></span></p>
<p class="line867"><span class="anchor" id=
"line-345"></span><span class="anchor" id="line-346"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_189" lang="en">
<span class="line"><span class=
"n">SDL_PeepEvents</span><span class="p">(</span><span class=
"o">&amp;</span><span class="n">event</span><span class=
"p">,</span> <span class="mi">1</span><span class=
"p">,</span> <span class="n">SDL_GETEVENT</span><span class=
"p">,</span> <span class="n">SDL_MOUSEBUTTONDOWN</span><span class=
"p">,</span> <span class="n">SDL_MOUSEBUTTONDOWN</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-347"></span><span class="anchor" id=
"line-348"></span><span class="anchor" id="line-349"></span>
<p class="line867"></p>
<h3 id="Audio">Audio</h3>
<span class="anchor" id="line-350"></span><span class="anchor" id=
"line-351"></span>
<p class="line874">The good news for audio is that, with one
exception, it's entirely backwards compatible with 1.2. If you want
the new features, they're available to you, but you'll probably
just compile and run without them. <span class="anchor" id=
"line-352"></span><span class="anchor" id="line-353"></span></p>
<p class="line862">That one really important exception: The audio
callback does NOT start with a fully initialized buffer anymore.
You <em><strong>must</strong></em> fully write to the buffer in all
cases. If you don't have enough audio, your callback should write
silence. If you fail to do this, you'll hear repeated audio, or
maybe audio corruption. If you want to restore the old behavior of
unconditionally initializing the buffer, just put an
SDL_memset(stream, 0, len) at the start of your callback.
<span class="anchor" id="line-354"></span><span class="anchor" id=
"line-355"></span><span class="anchor" id="line-356"></span></p>
<p class="line867"></p>
<h3 id="Joysticks">Joysticks</h3>
<span class="anchor" id="line-357"></span><span class="anchor" id=
"line-358"></span>
<p class="line874">Joystick events now refer to an SDL_JoystickID.
This is because SDL 2.0 can handle joysticks coming and going, as
devices are plugged in and pulled out during your game's lifetime,
so the index into the device list that 1.2 uses would be
meaningless as the available device list changes. <span class=
"anchor" id="line-359"></span><span class="anchor" id=
"line-360"></span></p>
<p class="line874">To get an SDL_JoystickID for your opened
SDL_Joystick*, call: <span class="anchor" id=
"line-361"></span><span class="anchor" id="line-362"></span></p>
<p class="line867"><span class="anchor" id=
"line-363"></span><span class="anchor" id="line-364"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_190" lang="en">
<span class="line"><span class=
"n">SDL_JoystickID</span> <span class="n">myID</span> <span class=
"o">=</span> <span class=
"n">SDL_JoystickInstanceID</span><span class=
"p">(</span><span class="n">myOpenedStick</span><span class=
"p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-365"></span><span class="anchor" id=
"line-366"></span>
<p class="line862">And compare the joystick events'
<strong>which</strong> field against <tt class=
"backtick">myID</tt>. If you aren't using the event queue for
joysticks, <a href="index.html@SDL_JoystickGetAxis.html">SDL_JoystickGetAxis</a>()
and friends work just like SDL 1.2. <span class="anchor" id=
"line-367"></span><span class="anchor" id="line-368"></span></p>
<p class="line862">You should also check out the new <a href="index.html@CategoryGameController.html">Game Controller API</a> too, because it's
cool, and maybe you did a lot of tap dancing with the 1.2 API that
this new code would solve more cleanly. You can find it in
SDL_gamecontroller.h. The Game Controller API integrates really
nicely with Steam Big Picture Mode: you get automatic configuration
of most controllers, and a nice UI if you have to manually
configure it. In either case, Steam passes this configuration on to
your SDL application. <span class="anchor" id=
"line-369"></span><span class="anchor" id="line-370"></span></p>
<p class="line874">Support for the older joystick API
(/dev/input/js*) for Linux has been dropped from SDL2. SDL2 only
supports the newer events API (/dev/input/event*) for joysticks.
These events are not normally readable for normal user accounts, so
even if joysticks are plugged in you will likely have none
detected. This is something that end users will have to configure
for themselves. <span class="anchor" id=
"line-371"></span><span class="anchor" id=
"line-372"></span><span class="anchor" id="line-373"></span></p>
<p class="line867"></p>
<h3 id="Threads">Threads</h3>
<span class="anchor" id="line-374"></span><span class="anchor" id=
"line-375"></span>
<p class="line867"><tt class="backtick">SDL_KillThread()</tt> is
gone. It was never safe or reliable. The best replacement is to set
a flag that tells a thread it should quit. That thread should check
the flag with some frequency, and then the "killing" thread calls
<a href="index.html@SDL_WaitThread.html">SDL_WaitThread</a>() to clean up.
<span class="anchor" id="line-376"></span><span class="anchor" id=
"line-377"></span></p>
<p class="line867"><a href="index.html@SDL_CreateThread.html">SDL_CreateThread</a>() takes an extra parameter
now, a name for the thread, which can be used by debuggers to
identify it. If you don't care about that, just stuff an extra NULL
into your function call. <span class="anchor" id=
"line-378"></span><span class="anchor" id=
"line-379"></span><span class="anchor" id="line-380"></span></p>
<p class="line867"></p>
<h3 id="Audio_CDs">Audio CDs</h3>
<span class="anchor" id="line-381"></span><span class="anchor" id=
"line-382"></span>
<p class="line862">The 1.2 CD API is completely gone. There's no
replacement. Chances are you aren't shipping your music as CD-Audio
tracks on a disc at this point, if you're shipping a disc at all.
You can use <a class="http" href="http://www.vorbis.com/">Ogg
Vorbis</a> or some other audio file format for music, many of which
are provided by SDL_mixer. <span class="anchor" id=
"line-383"></span><span class="anchor" id=
"line-384"></span><span class="anchor" id="line-385"></span></p>
<p class="line867"></p>
<h3 id="Dead_platforms">Dead platforms</h3>
<span class="anchor" id="line-386"></span><span class="anchor" id=
"line-387"></span>
<p class="line874">We ripped out a bunch of old platforms, like
OS/2 and Mac OS 9. It would be easier to list the ones we still
support: Windows (XP and later), Linux, Mac OS X, iOS, Android. In
SDL tradition, there are others on the periphery that work but
aren't heavily supported, like Haiku and Sony PSP. We'll add any
platform that someone sends patches for, but it seemed like it was
time to say goodbye to some old friends when moving to the new
version. <span class="anchor" id="line-388"></span><span class=
"anchor" id="line-389"></span><span class="anchor" id=
"line-390"></span></p>
<p class="line867"></p>
<h3 id="Mobile_platforms">Mobile platforms</h3>
<span class="anchor" id="line-391"></span><span class="anchor" id=
"line-392"></span>
<p class="line874">There have been, for many years, unofficial
ports of SDL 1.2 to iOS and Android. SDL now supports these
platforms directly, and the 2.0 API is much better suited to them.
Most of the advice you've gotten elsewhere in this document
applies, but there are a few other things worth noting.
<span class="anchor" id="line-393"></span><span class="anchor" id=
"line-394"></span></p>
<p class="line874">First, there are certain events that only apply
to mobile devices, or better said, apply to the way mobile device
OSes tend to operate in a post-iPhone world. We originally tried to
map these to the existing SDL events (such as "your application is
going to the background" being treated like a desktop window losing
focus), but there's a more urgent concern: most of these events
need an immediate response, and if the app doesn't give one, the OS
will kill your application. <span class="anchor" id=
"line-395"></span><span class="anchor" id="line-396"></span></p>
<p class="line862">As such, we've added new SDL events for some
Android and iOS specific details, but you should set up an SDL
event filter to catch them as soon as the OS reports them, because
waiting until your next <a href="index.html@SDL_PollEvent.html">SDL_PollEvent</a>() loop will be too late.
<span class="anchor" id="line-397"></span><span class="anchor" id=
"line-398"></span></p>
<p class="line862">For example, there's
SDL_APP_WILLENTERBACKGROUND, which is iOS's <tt class=
"backtick">applicationWillResignActive()</tt>, and if you draw to
the screen after this event arrives, iOS terminates your process.
So you want to catch this immediately: <span class="anchor" id=
"line-399"></span><span class="anchor" id="line-400"></span></p>
<p class="line867"><span class="anchor" id=
"line-401"></span><span class="anchor" id=
"line-402"></span><span class="anchor" id=
"line-403"></span><span class="anchor" id=
"line-404"></span><span class="anchor" id=
"line-405"></span><span class="anchor" id=
"line-406"></span><span class="anchor" id=
"line-407"></span><span class="anchor" id=
"line-408"></span><span class="anchor" id=
"line-409"></span><span class="anchor" id=
"line-410"></span><span class="anchor" id=
"line-411"></span><span class="anchor" id=
"line-412"></span><span class="anchor" id=
"line-413"></span><span class="anchor" id="line-414"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_191" lang="en">
<span class="line"><span class="kt">int</span> <span class=
"n">SDLCALL</span> <span class=
"nf">myEventFilter</span><span class="p">(</span><span class=
"kt">void</span> <span class="o">*</span><span class=
"n">userdata</span><span class="p">,</span> <span class=
"n">SDL_Event</span> <span class="o">*</span> <span class=
"n">event</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class=
"k">if</span> <span class="p">(</span><span class=
"n">event</span><span class="o">-&gt;</span><span class=
"n">type</span> <span class="o">==</span> <span class=
"n">SDL_APP_WILLENTERBACKGROUND</span><span class=
"p">)</span> <span class="p">{</span>
</span><span class="line">        <span class=
"c1">// free up resources, DON'T DRAW ANY MORE until you're in the foreground again!</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// etc</span>
</span><span class="line">    <span class=
"k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class=
"c1">// somewhere near startup...</span>
</span><span class="line">
</span><span class="line"><span class=
"c1">// this calls myEventFilter(data, event) as soon as event is generated.</span>
</span><span class="line"><span class=
"n">SDL_AddEventWatch</span><span class="p">(</span><span class=
"n">myEventFilter</span><span class="p">,</span> <span class=
"n">data</span><span class="p">);</span>
</span>
</pre></div>
<span class="anchor" id="line-415"></span><span class="anchor" id=
"line-416"></span>
<p class="line862">Second, there are real touch events now, instead
of trying to map this to mouse input. You can track touches,
multiple fingers, and even complex gestures. You probably want to
use those. Refer to SDL_touch.h for a list of these functions, and
look for <a href="index.html@SDL_Finger.html">SDL_Finger</a>* in SDL_events.h.
<span class="anchor" id="line-417"></span><span class="anchor" id=
"line-418"></span></p>
<p class="line862">There are a handful of other mobile-friendly
functions, like <a href="index.html@SDL_StartTextInput.html">SDL_StartTextInput</a>(), which will show the
on-screen keyboard. Make use of them. <span class="anchor" id=
"line-419"></span><span class="anchor" id="line-420"></span></p>
<p class="line874">In addition, there are also Android and iOS
specific functions, to let you access platform-specific features
that wouldn't make sense in a general API. Refer to SDL_system.h
for a list of these functions. <span class="anchor" id=
"line-421"></span><span class="anchor" id=
"line-422"></span><span class="anchor" id="line-423"></span></p>
<p class="line867"></p>
<h3 id="RWops">RWops</h3>
<span class="anchor" id="line-424"></span><span class="anchor" id=
"line-425"></span>
<p class="line867"><a href="index.html@SDL_RWread.html">SDL_RWread</a>() and
<a href="index.html@SDL_RWwrite.html">SDL_RWwrite</a>() now return <tt class=
"backtick">0</tt> on error instead of <tt class="backtick">-1</tt>.
<span class="anchor" id="line-426"></span><span class="anchor" id=
"line-427"></span></p>
<p class="line862">If you wrote your own <a href="index.html@SDL_RWops.html">SDL_RWops</a> implementation, the function signatures
have changed. Functions now use <tt class="backtick">Sint64</tt>
and <tt class="backtick">size_t</tt> instead of <tt class=
"backtick">int</tt> so they can work with large files. In many
cases, you can just update your function signatures and keep
working as before, but if you had bumped up against these
limitations, you might be happy to have a solution. Calling
applications should know that the return values have changed.
<span class="anchor" id="line-428"></span><span class="anchor" id=
"line-429"></span></p>
<p class="line862">There is also a <strong>size</strong> method to
RWops, now. This lets a RWops report the size of the stream without
having to make the app seek to zero bytes from the end; in other
words, you can report a total size for streams that can't seek. For
streams that can't even do that, you can still return -1.
<span class="anchor" id="line-430"></span><span class="anchor" id=
"line-431"></span><span class="anchor" id="line-432"></span></p>
<p class="line867"></p>
<h3 id="Add-on_libraries">Add-on libraries</h3>
<span class="anchor" id="line-433"></span><span class="anchor" id=
"line-434"></span>
<p class="line862">The official extensions SDL_image, SDL_ttf,
SDL_mixer and SDL_net have a version dedicated to SDL 2.0 :
SDL2_image, SDL2_ttf, SDL2_mixer and SDL2_net. You may need to
download them from the <a class="http" href=
"http://hg.libsdl.org/">mercurial repositories</a> for the latest
fixes. Subsequently, of course, you will have to link e.g.
SDL2_image, not SDL_image, to compile your program. <span class=
"anchor" id="line-435"></span><span class="anchor" id=
"line-436"></span></p>
<p class="line874">These libraries will not be supporting 1.2 going
forward, and any compatibility with 1.2 is likely to vanish at some
point from newer versions. <span class="anchor" id=
"line-437"></span><span class="anchor" id="line-438"></span></p>
<p class="line867"><a class="http" href=
"http://www.ferzkopp.net/joomla/content/view/19/14/">SDL_gfx</a>
can also be compiled with 2.0 starting since 2.0.21 (May 2010).
<span class="anchor" id="line-439"></span><span class="anchor" id=
"line-440"></span><span class="anchor" id="line-441"></span></p>
<p class="line867"></p>
<h3 id="Summary_of_some_renamed_or_replaced_things">Summary of some
renamed or replaced things</h3>
<span class="anchor" id="line-442"></span><span class="anchor" id=
"line-443"></span>
<p class="line874">A short cheat sheet where some of the old
functions and other stuff went: <span class="anchor" id=
"line-444"></span></p>
<ul>
<li>
<p class="line862">SDL_<a class="nonexistent" href="index.html@SetVideoMode.html">SetVideoMode</a>(): use <a href="index.html@SDL_CreateWindow.html">SDL_CreateWindow</a>() instead (along with
<a href="index.html@SDL_CreateRenderer.html">SDL_CreateRenderer</a>() if you want
to do classic 2D rendering and not OpenGL) <span class="anchor" id=
"line-445"></span></p>
</li>
<li>
<p class="line862">SDL_<a class="nonexistent" href="index.html@ListModes.html">ListModes</a>(): use <a href="index.html@SDL_GetDisplayMode.html">SDL_GetDisplayMode</a>()/<a href="index.html@SDL_GetNumDisplayModes.html">SDL_GetNumDisplayModes</a>() instead
<span class="anchor" id="line-446"></span></p>
</li>
<li>
<p class="line862">SDL_<a class="nonexistent" href="index.html@UpdateRect.html">UpdateRect</a>()/SDL_Flip(): use <a href="index.html@SDL_RenderPresent.html">SDL_RenderPresent</a>() instead <span class=
"anchor" id="line-447"></span></p>
</li>
<li>
<p class="line862">SDL_Surface/2D rendering: surfaces still exist,
but it is recommended that instead of using SDL_Surfaces, you use
<a href="index.html@SDL_Texture.html">SDL_Texture</a>s with an 2D accelerated
renderer (<a href="index.html@SDL_CreateRenderer.html">SDL_CreateRenderer</a>())
where possible <span class="anchor" id="line-448"></span></p>
</li>
<li>
<p class="line862">SDL_<a class="nonexistent" href="index.html@VideoInfo.html">VideoInfo</a>: use <a href="index.html@SDL_GetRendererInfo.html">SDL_GetRendererInfo</a>()/<a href="index.html@SDL_GetRenderDriverInfo.html">SDL_GetRenderDriverInfo</a>() instead
<span class="anchor" id="line-449"></span></p>
</li>
<li>
<p class="line862">SDL_<a class="nonexistent" href="index.html@GetCurrentVideoDisplay.html">GetCurrentVideoDisplay</a>(): use
<a href="index.html@SDL_GetWindowDisplayIndex.html">SDL_GetWindowDisplayIndex</a>()
instead <span class="anchor" id="line-450"></span></p>
</li>
<li>
<p class="line862">SDL_VIDEORESIZE event: the new equivalent is
<a href="index.html@SDL_WindowEvent.html">SDL_WINDOWEVENT_RESIZE</a> <span class=
"anchor" id="line-451"></span><span class="anchor" id=
"line-452"></span><span class="anchor" id="line-453"></span></p>
</li>
</ul>
<p class="line867"></p>
<h3 id="Other_stuff">Other stuff</h3>
<span class="anchor" id="line-454"></span><span class="anchor" id=
"line-455"></span>
<p class="line874">There's an enormous amount of new and
interesting functionality in SDL 2.0 that 1.2 couldn't even dream
of. We've only tried to explain what you might have to do to get
your 1.2 program running on 2.0 here, but you should explore the
documentation for things that you might have always wished for and,
until now, done without. For example, every game I've ever ported
ended up with a message box function that looked like this:
<span class="anchor" id="line-456"></span><span class="anchor" id=
"line-457"></span></p>
<p class="line867"><span class="anchor" id=
"line-458"></span><span class="anchor" id=
"line-459"></span><span class="anchor" id=
"line-460"></span><span class="anchor" id="line-461"></span></p>
<div class="codearea" dir="ltr" lang="en">
<pre dir="ltr" id="CA-pygments_192" lang="en">
<span class="line"><span class="cp">#if USING_SDL</span>
</span><span class="line"><span class=
"n">fprintf</span><span class="p">(</span><span class=
"n">stderr</span><span class="p">,</span> <span class=
"s">"MSGBOX: %s</span><span class="se"></span><span class=
"s">%s</span><span class="se"></span><span class=
"s">"</span><span class="p">,</span> <span class=
"n">title</span><span class="p">,</span> <span class=
"n">text</span><span class="p">);</span>   <span class=
"c1">// oh well.</span>
</span><span class="line"><span class="cp">#endif</span>
</span>
</pre></div>
<span class="anchor" id="line-462"></span><span class="anchor" id=
"line-463"></span>
<p class="line862">Now there's <a href="index.html@SDL_ShowSimpleMessageBox.html">SDL_ShowSimpleMessageBox</a>(). You're
welcome! <span class="anchor" id="line-464"></span><span class=
"anchor" id="line-465"></span></p>
<p class="line862">If you skipped ahead, go back and check out all
the new features <a href="index.html@MigrationGuide.html#Overview_of_new_features">at the overview</a>!
<span class="anchor" id="line-466"></span><span class="anchor" id=
"bottom"></span></p>
</div>
</body></html>