<html>
<!--65816nfo.HTM-->
<head><title>65816 Programming Primer</title>
<META NAME="author" CONTENT="Brett J. Tabke">
<META NAME="keywords" CONTENT="65816, SCPU, Super CPU, Western Design, Programming, ML, Assembler, Machine Language">
<META NAME="description" CONTENT="Western Design 65816 Information, tutor">
</head>
<base href="http://www.netins.net/showcase/phdss/">

<body bgcolor="#ffffff" text="#000000" background="tan.gif">
<center><h1 align=center><a name="65816prime">A 65816 Primer</a></h1></center>
<p>
<center>
<img border=0 src="rocketli.gif" hspace="10" vspace="10" alt="[----------------------------------------------------------]">
</center>
</p>
<font size="2">
<p>
<strong><i>No republication or redistribution of the following is permitted
without the authors express written consent.</strong></i><br>
</p> <p>
<font size="3">
<h2><a name="#contents">Table of Contents</a></h2><br>
<hr>
</p> <p>
<pre><br>
     i   <a href="#pref"> Preface</a>
     1.00<a href="#1.00"> Introduction</a>
     2.00<a href="#2.00"> New 65816 Instructions</a>
     3.00<a href="#3.00"> 65816 Native Mode Programming Model</a>
     3.01<a href="#3.01">    Native Mode Processor Status Register</a>
     3.10<a href="#3.10"> Native Mode Registers</a>
     3.11<a href="#3.11">    Accumulator:</a>
     3.12<a href="#3.12">    X,Y Index Registers</a>
     3.13<a href="#3.13">    Direct Page Register (D)</a>
     3.14<a href="#3.14">    Stack Pointer (S)</a>
     3.15<a href="#3.15">    Program Bank Register (PBR)</a>
     3.16<a href="#3.16">    Data Bank Register (DBR)</a>
     3.20<a href="#3.20">    Status Register</a>
     3.21<a href="#3.21">       Emulation Bit E: Hidden Bit</a>
     3.22<a href="#3.22">       Sixteen BIT User Registers</a>
     3.23<a href="#3.23">       Index Register Select</a>
     3.24<a href="#3.24">       Accumulator/Memory Select</a>
     3.30<a href="#3.30">    Setting Status Register Bits</a>
     4.00<a href="#4.00"> 65816 Emulation Mode Programming Model</a>
     4.10<a href="#4.10">    Emulation Mode Registers</a>
     5.00<a href="#5.00"> Relocating the Stack and Direct Page</a>
     6.00<a href="#6.00"> Addressing Modes</a>
     6.10<a href="#6.10">       New 65816 Specific Addressing Modes</a>
     6.20<a href="#6.20">       Addressing Mode Descriptions</a>
     7.00<a href="#7.00"> Interrupts</a>
     7.10<a href="#7.10">      Hardware Vectors</a>
<br>
     Appendix A:<a href="#appena"> 65816 Instruction Set</a>
     Appendix B:<a href="#appenb"> Composite Instruction List</a>
     Appendix C:<a href="#appenc"> IC Pinouts</a><br>
</pre>
</p> <p>

Disclaimer:<br>
<p>
Some of the following information was referenced with various documents and
public documentation available for the Apple IIGS computer system and the
Super NES game console system via the world wide web and other user group
publications.
No claim is made or intended against any copyrighted information that
<i>may</i> be contained within this document.  The main sub-content that
could be construed as a copyright infringement, would be the usage of
mnemonic tables and the similarity of programming models.  Although these
tables were built specifically for this project, it is unclear what the
legal status of mnemonic information is at present.  <i>Brett Tabke
1997</I><br>
</p>

<p>
This document is intended to aid those programming the 65816 Processor
from <a href="http://www.wdesignc.com/">The Western Design Center</a>.
This chip is the basis for the Apple IIGS, the Creative Micro Designs
SuperCPU addon cartridge for the Commodore 64 & 128, and the Super NES
game console that are all based around the 65816 micro processor.<br>
</p>
<p>
<hr></p> <p>
<a name="pref">Preface</a>
</p><br>
<p>
This document was pulled from several chapters of book project I had
started.  I'd intended to publish a small booklet on programming the CMD
Super CPU cartridge detailing the operation of the 65816 - however, I
have been unable to acquire a release to republish some critical
information.  So, the following is a few chapters that I feel are worthy
of public disclosure and distribution.<br> </p>
<p> </p><br>

<i>HTML Conversion Notes</i><br>
</p>
<p>
This document was originally in IBM CG/ANSI format and the conversion to
HTML was marginal.  Even with the file being fairly generic text,
four different browsers rendered it differently.  Lynx 2.7 and Lynx
2.6 will not render it the same - I tried to strike a happy medium - your
mileage may vary.<br>
</p>
<br><br>

<a href="#contents">TOC</a>


<center>
<img border=0 src="questjet.gif" hspace="10" vspace="10" alt="[ Image Jet ]">
<br></center>
<p><br>
<hr></p> <p>
<a name="1.00"><b>1.00 Introduction</b></a><br>
-----------------<br>
</p><br><br>
<p>
    Welcome to the world of 65816 programming.  The 65816 is an
advanced upgrade to the vintage 6502 Central Processing Unit.  The
main new features include full 24 bit addressing for direct memory
access of up to 16 megabytes.  Additionally, the 65816 offers full
6502 emulation, new addressing modes, full 16 bit user registers,
and dozens of new instructions.<br>
</p> <p>
    If you have been a 6502 programmer for long, the advantages of
the 65816 will become clear very quick.  Regardless of CPU operating
speed (mhz) a the 65816 will operate a bit faster simply by the
nature of the 16 bit user registers.  By using 16 bit registers for
operations such as addition and subtraction the 65816 also offers
the programmer a substantial speed increase.
</p> <p>
     The following document is not meant as a definitive guide to
programming the 65816, but rather a primer for those who are
familiar with the 6502 and wish to find the new 65816 (good) stuff.<br>
</p>
<p>
     The 65816 offers two primary modes of operation, Native 65816
Mode and 6502 emulation mode.  The default power-up status of the
processor is in 6502 emulation mode.  Other than correcting a few
bugs in the 6502, emulation mode "looks and feels" just like a 6502.<br>
</p>
<p>
     There are a few notable differences between the 65816's
emulation mode and the original 6502.  The 6502 opcodes that were
unimplemented, are now available as additional instructions on the
65816, thus they will not produce the results they do on a stock
NMOS 6502 CPU.  The 65816 implements ALL of the available 256
opcodes, whether in emulation or Native mode.<br>
</p>
<p>
    Also different between a 6502 and emulation mode is that the
indirect jump JMP ($XXXX) bug that caused the processor to retrieve
the wrong data when the low byte was $xx has been fixed.<br>
</p>
<p>
     While in emulation mode, the 65816's Direct (zero) Page
register is set for zero.  The Stack pointer high byte is set for
one (just as a 6502).  The Program and Data Bank Registers are
initialized to zero.  Timing of all instructions is identical.
</p>
<p>
     While in Native mode, the processor has full access to the 16
megabyte address space via 24 bit addressing.  Native mode also
makes available several new and extended processor registers.  The
65816 has the ability to relocate the Stack and Zero Page any where
within the first 64k bank of memory.  For old Commodore 128
programmers, this will sound suspiciously like the 128's Memory
Management Units ability to relocate zero page and the stack also -
so it will be old hat from the start.  (On a side note, it will be
interesting to program on CMD's Super CPU 128 - which will give you
a Relocatable Relocatable Zero Page and Stack.  hmmm ;)<br>
</p>
<p>
     Native mode also opens up the world of 16 bit user registers.
The accumulator may be 8 or 16 bits and the XY index registers may
also be 8 or 16 bits.  The accumulator maybe seen in terms of two 8
bit registers with one accessible and the other hidden, or as a
full 16 bit register.  While the accumulator is set for 16 bits,
memory is also treated in 16 bit (2 byte) fashion.<br>
</p>
<p>
     Two other new registers are the Data Bank Register and the
Program Bank register.  The Program Bank Register functionally
extends the program counter out to 24 bits, while the Data Bank
register allows code flow control to branch or jump to points
outside of the 6502's 64k address space.<br>
</p>
<p>
      Lastly, while in Native mode the status register of the 65816
includes several new bits.  The old BRK bit is no longer needed as
the 65816 has a BRK hardware vector.  The BRK bit is now replaced
with the X bit to select either 8 or 16 bit index registers.
However while in emulation mode, the BRK bit is still there.  The
old "reserved" bit 5 of the status register is replaced with the
16/8 bit accumulator/memory select bit.  There is also a hidden
emulation bit that is only accessible by exchanging it will the
carry flag.<br>
</p>
<br>
<p>
Here is a run down of some of the new fun stuff:
</p><ul>
   <li> XYA registers can be 16 or 8 bits wide.
   <li> Wow, two actual Block Move Memory instructions.
   <li> New push/pull instructions phx,plx,phy,ply.
   <li> New xfer instructions tyx,txy.
   <li> Set or Reset any memory bit without loading the accumulator.
   <li> INC and DEC the accumulator.
   <li> JSR indirect, Branch Always, or Branch Long to 64k.
   <li> Zero Page has been renamed to Direct Page.  Like many
strange things, this will be totally confusing at first.  The only
thing you can do is, "get over it and get on with it".
</ul>
<a href="#contents">TOC</a>

<br>
<pre>
<a name="2.00"><b>2.00 New 65816 Instructions:</b></a>
<b>----------------------------</b>
</pre>
  There are some new instructions worthy of short detail:<br>
<p>
   <b>New transfer instructions include:</b><br>
</p> <p><pre>
     <b>TXY,TYX</b> xfer between x and y.
     <b>TCD,TCD</b> xfer between the accumulator and direct page pointer(D).
     <b>TCS,TSC</b> xfer between the accumulator and stack pointer(S).
     <b>XBA    </b> exchange the low 8 bits (a) and the high 8 bits
                    of the accumulator.
     <b>XCE    </b> exchange the contents of the emulation bit (E) with
                    the contents of the carry flag (C).<br>

<br>
</pre>
</p> <p>
   <b>New Stack pushes and pulls:</b><br>
</p> <p><pre>
     <b>PHX,PHY,PLX,PLY</b>  push and pull the XY index registers.
     <b>PHB,PLB</b>     to push/pull the data bank register.
     <b>PHK    </b>     to push the program bank register (no pull present)
     <b>PHD,PLD</b>     to push/pull the direct page register.
     <b>PEA    </b>     to push effect absolute address.
     <b>PEI    </b>     to push effective indirect address.
     <b>PER    </b>     to push effective relative address.
<br>
   <b>Misc:</b>
     <b>MVN</b>   Move block in negative direction.
     <b>MVP</b>   Move block in positive direction.
     <b>STZ</b>   Store a zero to any location.
     <b>BRA</b>   Branch always.
     <b>BRL</b>   Branch to any address in bank 0 (64k).
     <b>RTL</b>   Return Long. Pulls one more byte. (pc bank byte)
<br>
<p></pre>
As you can see, there is plenty new to digest.  The remainder of
this document will assume prior 6502 knowledge.  Lets go.

<br><a href="#contents">TOC</a><br>

</p> <p><pre>
<hr>
==========================================
<a name="3.00"><b>3.00 65816 Native Mode Programming Model</b></a>
==========================================
<hr><br>

Bits:23                          15                    7                 0
                                 /--------------------l-------------------\
                                 IAccumulator (B) (A or C) Accumulator (A)I
                                 \--------------------I-------------------/
     /--------------------------\
     I Data Bank Register (DBR) I
     \--------------------------/
                                 /--------------------l-------------------\
                                 I           X Index  I Register (X)      I
                                 \--------------------I-------------------/
                                 /--------------------l-------------------\
                                 I           Y Index  I Register (Y)      I
                                 \--------------------I-------------------/
      ---------------------------/--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Direct I Page Pointer (D)  I
      ---------------------------\--------------------I-------------------/
      ---------------------------/--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Stack  I Pointer (S)       I
      ---------------------------\--------------------I-------------------/
     /---------------------------l--------------------l-------------------\
     IProgram Bank Register(PBR) I            Program I Counter (PC)      I
     \---------------------------I--------------------I-------------------/


===================================
<a name="3.01"><b>3.01 Processor Status Register (P)</b></a>
===================================


Bits  7   6   5   4   3   2   1   0
                                /---\
                                I e --- Emulation 0 = Native Mode
    /---l---l---l---l---l---l---+---I
    I n I v I m I x I d I i I z I c I
    \-l-I-l-I-l-I-l-I-l-I-l-I-l-I-l-/
      I   I   I   I   I   I   I   \-------- Carry 1 = Carry
      I   I   I   I   I   I   \------------- Zero 1 = Result Zero
      I   I   I   I   I   \---------- IRQ Disable 1 = Disabled
      I   I   I   I   \------------- Decimal Mode 1 = Decimal, 0 = Binary
      I   I   I   \-------- Index Register Select 1 = 8-bit, 0 = 16-bit
      I   I   \-------- Memory/Accumulator Select 1 = 8-bit, 0 = 16 bit
      I   \----------------------------- Overflow 1 = Overflow
      \--------------------------------- Negative 1 = Negative

<a name="3.01"><b>65816 Native Mode Programming Model</b></a>

<br><a href="#contents">TOC</a><br>

<br>
======================================
<a name="3.10"><b>3.10 Native Mode Registers</b></a>
======================================
<br>
<a name="3.11"><b>3.11 Accumulator</b></a>
-----------------
<p></pre>
  Although shown as a 16 bit register, it may be either 16 or 8
  depending on the status of bit 5 (memory/accumulator select) of
  the status register bit designated M.<br>
</p>
<p>
  When in 8 bit mode (M=1) then the accessible low order 8 bit
  accumulator is designated as A and the hidden but exchangeable is
  designated B. When in full 16 bit accumulator mode (M=0) then the
  accumulator is designated as C.<br>
</p><pre>
<a name="3.12"><b>3.12 X,Y Index Registers</b></a>
-------------------------
<p></pre>
   The X and Y index registers are 8 or 16 bit selectable.  When
   status register bit 4 designated X is set to 1 then 8 bit
   registers are selected.  When set to 0 then 16 bit registers are
   selected.<br>
</p><pre>
<br><a href="#contents">TOC</a><br>
<br>
<a name="3.13"><b>3.13 Direct Page Register (D)</b></a>
------------------------------
<p></pre>
This register is formerly known as Zero Page.  The Direct Page
pointer specifies where in the first bank of 64k Direct Page (zero
page) will be located.  The Direct Page may be moved to ANY location
within Bank 0.<br>
</p> <p>
The Bank byte (bits 16-23) is shown in a dashed line to represent
the fact that the Direct Page is always located within bank 0.<br>
</p> <p>

<pre>
<a name="3.14"><b>3.14 Stack Pointer (S):</b></a>
-----------------------
</pre><p>
   Like the Direct (zero) Page Pointer, the Stack is now totally
   relocatable within Bank 0 (first 64k) of memory.
   The Bank byte (bits 16-23) is shown in a dashed line to represent
   the fact that the Stack is always located within bank 0.
   While in Native Mode the stack is not restricted to 256 bytes in
   length.<br>
   while in emulation mode (e=1) the stack is located at page 1.<br>
</p><pre>
<br><a href="#contents">TOC</a><br>
<br>
<a name="3.15"><b>3.15 Program Bank Register (PBR):</b></a>
---------------------------------
<p></pre>
     Much like the DBR below, the Program Bank Register is used to
     specify address's above and beyond the 6502 64k limit.  The PBR
     is referred to as the Bank Byte or the highest 8 bits of the
     Program Counter.  Flow control instructions such as JSR and
     JMP, may jump to full 23 bit address's.  The PBR is used to
     specify the highest order 8 bits of the effective address.
     However; relative branches do not roll out of the current bank.
     Branch commands that branch across $FFFF roll back into the
     current bank.  Also; program segments may not cross bank
     boundaries - the program counter goes from $FFFF to $0000
     during such and occurrence.
</p>
<br><br>
<pre>
<a name="3.16"><b>3.16 Data Bank Register (DBR):</b></a>
------------------------------
<p></pre>
    Certain addressing modes take advantage of the 65816's ability
    to address up to 16meg of data.  Those modes that retrieve and
    store data to absolute 16 meg/(24 bit address's use the DBR as
    the top 8 bits of the effective address.  The DBR is also
    referred to as the Data Bank Byte.  The term Bank Byte is used
    so that High Byte still refers to bits 8-15 of a given location
    or register.<br>
</p> <p>
    When indexed addressing mode branch across 64k bank boundaries,
    DBR is temporarily incremented.<br>
</p>
<br><a href="#contents">TOC</a><br>
<pre>
<a name="3.20"><b>3.20 Status Register</b></a>
=====================
<p></pre>
    The status register bits 7,6,3,2,1,0 (nvdizc) function the same
    as the 6502 status register bits.
</p> <p>
    The B break bit is no longer needed to detect a BRK. Instead a
    new hardware vector has been implemented to direct code flow
    to a OS ROM handler in the same way as an IRQ.  However, while
    in emulation mode (E=1) BRK and the B bit work as a 6502 does.<br>
</p>
<pre>

<a name="3.21"><b>3.21 Emulation Bit E: Hidden Bit</b></a>
--------------------------------
<p></pre>
    The emulation status bit E specifies whether the processor is in
    6502 emulation mode or Native 65816 mode.  1=emulation.  The
    processor powers up in default 6502 emulation mode.  When in
    6502 emulation mode, the processor is functionally a 6502.  With
    the exceptions of un implemented opcodes, all other opcodes
    perform identically to their true 6502 counter parts.  In
    emulation mode, the stack is defined as page one, direct page is
    defined as page zero, and the Data Bank and Program Bank bytes
    are set to zero.  The additional 65816 opcodes are also
    available in emulation mode.<br>
</p> <p>
    The emulation status bit is a hidden or phantom bit that is not
    directly set, tested, or cleared.  Therefore, a new instruction
    is used to exchange the values of the carry bit and the
    emulation bit (XCE:eXchange Carry with emulation bit).  After
    exchanging, the carry can be tested to determine the previous
    status of the E bit.<br>
</p><pre>

    To switch to Native Mode use the following:<br>
<br>
        clc    ;clear carry to zero.<br>
        xce    ;exchange (swap) carry with the emulation bit.<br>
<br>
    To return to Emulation mode:<br>
<br>
        sec    ;set carry to one.
        xce    ;exchange (swap) carry with the emulation bit.<br><br>
<br>
<br><a href="#contents">TOC</a><br>

<a name="3.22"><b>3.22 Sixteen BIT User Registers</b></a>
--------------------------------
<p></pre>
    The main advantage of the 65816 over the 6502 is that the
    Accumulator and the XY index registers can be toggle between 8
    and 16 bits wide.  The width of the Accumulator and the XY
    registers are independently selectable.  Thus you may select any
    combination of either:<br>
</p><pre>
       16 bit accum. m=0  - 16 bit XY regs x=0
       16 bit accum. m=0  -  8 bit XY regs x=1
        8 bit accum. m=1  - 16 bit XY regs x=0
        8 bit accum. m=1  -  8 bit XY regs x=1
<p></pre>
    When the accumulator is switched from or to 16 bits, the high
    order byte is retained in either direction.<br>
</p> <p>
    When the XY registers are switched from 16 bits to 8 bits, the
    high byte (bits 8-15) are lost.  When switching the XY registers
    to 16 bits, the high byte becomes a zero.<br>
</p> <p><pre>
<br><a href="#contents">TOC</a><br>
<br>
<a name="3.23"><b>3.23 Status Bit 4 X: Index Register Select</b></a>
-------------------------------------------
<p></pre>
    Bit 4 of the status register selects either 8 bit or 16 bit XY
    index register operation.  When x=1 (8 bit), the XY registers
    function identically to the 6502 index registers.
</p>
<p>
    When x=0 (16 bit), both the X and Y registers become 16 bits
    wide.  All operations involving the X and Y registers act on all
    16 bits of the index register.
</p>
<p>
    When switching from 8 to 16 or 16 to 8 bit index register, the
    high byte of either X or Y will be come zero.
</p>
    While in emulation mode (E=1) bit 4 is the B BRK flag bit.<br>
<br><pre>
<br><a href="#contents">TOC</a><br>

<a name="3.24"><b>3.24 Status Bit 5: Accumulator/Memory Select</b></a>
---------------------------------------------
</pre><p>
    Bit 5 specifies whether the accumulator will be treated as an 8
    bit or 16 bit register.  When in 16 bit mode (m=0) all
    operations involving the accumulator will act upon 16 bits of
    data.  Such as, when in 16 bit mode, a standard load (lda $1000)
    will load the load by ($1000) in the low order 8 bits of the
    accumulator and load ($1001) into the high order of the
    accumulator.<br>
</p> <p>
    When switching the accumulator from 16 to 8 or from 8 to 16
    bits, the high byte is perfectly retained.  While in 8 bit mode,
    the high byte of the accumulator (B) maybe exchanged with the
    low byte with the XBA instruction.<br>
</p> <p>
    While in emulation mode, bit 5 is not present.<br>
</p><br><br>
<br><a href="#contents">TOC</a><br>
<pre>
<a name="3.30"><b>3.30 Setting Status Register Bits</b></a>
----------------------------------
<p></pre>
     Two new instructions have been added to 65816 Native mode to
set and reset bits of the status register.  The two instructions are
SEP (set processor status bits) and REP (reset processor status
bits).  They both use a single byte operand to specify which bits
should be set or reset.  For example to set bit 4 of the status
register to 1 for 8 bit registers:
</p><br><pre>
          SEP  #%00010000   ;set bit 4.<br>
<br>
Or to clear bit 4 for 16 bit XY index registers:<br>
<br>
          REP #%00010000   ;reset (clear) bit 4.<br>
<br>
</pre>
You may set or reset more than 1 bit at a time.  For example, to set
both 16 bit accumulator/memory and 16 bit XY registers use the following:<br>
<br><pre>
          REP #%00110000   ;set 16 bit accum/xy registers.

<hr>
=============================================
<a name="4.00"><b>4.00 65816 Emulation Mode Programming Model I</b></a>
=============================================
<hr>

Bits:23                          15                    7                 0
                                  --------------------l-------------------\
                                 |Accumulator (B)    (C)   Accumulator (A)I
                                  --------------------I-------------------/
     /--------------------------\
     I Data Bank Register (DBR) I
     \--------------------------/
                                                      /-------------------\
                                                      I X Index Register  I
                                                      \-------------------/
                                                      /-------------------\
                                                      I Y Index Register  I
                                                      \-------------------/
      ---------------------------l--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I             Direct I Page Pointer (D)  I
      ---------------------------I--------------------I-------------------/
      ---------------------------l--------------------l-------------------\
     |         0 0 0 0 0 0 0 0   I    0 0 0 0 0 0 0 1 I Stack Pointer (S) I
      ---------------------------I--------------------I-------------------/
     /---------------------------l--------------------l-------------------\
     IProgram Bank Register(PBR) I            Program I Counter (PC)      I
     \---------------------------I--------------------I-------------------/


<a name="4.10"><b>4.10 Emulation Mode Registers</b></a><br>
=============================

<br><a href="#contents">TOC</a><br>

Emulation Mode Processor Status Register (P)
--------------------------------------------

Bits  7   6   5   4   3   2   1   0
                                /---\
                                I e --- Emulation 1 = 6502 Emulation Mode
    /---l---l---l---l---l---l---+---I
    I n I v I   I b I d I i I z I c I
    \-l-I-l-I---I-l-I-l-I-l-I-l-I-l-/
      I   I       I   I   I   I   \-------- Carry 1 = Carry
      I   I       I   I   I   \------------- Zero 1 = Result Zero
      I   I       I   I   \---------- IRQ Disable 1 = Disabled
      I   I       I   \------------- Decimal Mode 1 = Decimal, 0 = Binary
      I   I       \------------ Break Instruction 1 = BRK caused IRQ
      I   I
      I   \----------------------------- Overflow 1 = Overflow
      \--------------------------------- Negative 1 = Negative

              <b>65816 Emulation Mode Programming Model.</b>

</pre>
<br><a href="#contents">TOC</a><br>
<p>
The above 6502 emulation mode Programming Model shows some
interesting features of the 65816 while in emulation mode.  Even
though 16 bit index registers are not available in emulation mode,
you can still do the following:<br>
</p>
<ul>
      <li>Relocate Direct Page.
      <li>Use the stack addressing modes.
      <li>Swap the lower A accumulator with the hidden B accumulator.
      <li>The Program and Data Bank Registers can be changed.
      <li>Use the new instructions.<br>
</ul>
<p>
    Things lost or changed in Emulation mode verses Native mode:<br>
</p>
<ul>
      <li> The ability to use 16 bit user registers.  The M and X bits of the
           status register are returned to their 6502 form.
      <li> The utility of the Block Move instructions.  Block Move
        instructions use the index registers to specify the source
        and destination address's of a move - with only 8 bits
        available in emulation mode, you can only move data within
        zero page because the high byte will always be zero.<br>
      <li>Zero page addressing "wraps" in emulation mode, whereas in
        Native mode it rolls into the next page.<br>
      <li>The stack pointer is ALWAYS on page one.<br>
</ul><br>
<p>
     When switching from emulation to native mode the processor
replaces the B BREAK flag and bit 5 with the 65816 M and X flags,
and sets them to one.  This leaves the index registers and
accumulator/memory into 8 bit mode (which is the same as emulation
mode).  The remaining bits in the status register are unchanged.
The stack pointer remains at page one.<br>
</p> <p><br>
     When switching from native mode into emulation mode; the M and
X status register bit disappear, putting the accumulator and index
registers at 8 bit.  The X and Y low bytes are retained, but the
high bytes are lost.  The accumulator low and high bytes are
retained.  (of course the high byte is hidden but accessible with
the XBA instruction).  The stack pointer is returned to eights bits
with the high byte forced to one and the high byte is lost.<br>
</p> <p>
     I think that after you work with the 65816 in emulation mode you
will realize that it is not about what you lose over native mode,
but how much you gain over a 6502.  The fact that all of the extra
opcodes and instructions are still available even in emulation mode,
makes for a powerful processor even without the 16 bit registers.<br>
</p>
<pre>
<hr>
<br><a href="#contents">TOC</a><br>

<a name="5.00"><b>5.00 Relocating the Stack and Direct Page:</b></a>
------------------------------------------
</pre>
<p>    On power-up, the Stack is set to page one and the direct page
(Zero Page) to page zero.  When in emulation mode (E=1) the Stack is
initialized to Page one, and Zero page is initialized to Page zero
to emulate the default status of the 6502.<br>
</p> <p>
Relocating the Direct Page (formerly known as Zero Page) is
accomplished by use of the PLD:pull direct page instruction.<br>
<br><br><pre>
<samp>
        LDA #$5900   ; lda with immediate 16 bit data.
        PHA          ; on the stack with 16 bits.
        PLD          ; pull it back into the direct page register.<br><br>
</samp></pre>
<p>
Always keep in mind that PLD pulls 16 bits (2 bytes) off the
stack.  You may also use the TCD:transfer C register to Direct page
register. (the C register refers to the Accumulator as 16 bits)<br>
<pre></p> <p>
        LDA #$5900   ; load 16 bit accum with immediate 16 bit data.
        TCD          ; transfer accum to direct page register.<br>
</pre>
<p>
Although you generally will want to keep Direct Page starting
on an even 256 page boundary (low byte zero), you can specify a low
byte address at any 1-255 value.  However all of the Direct Page
(zero page) addressing modes will add one clock cycle to the
execution time if the low byte of the direct page register is other
than zero.<br>
</p> <p>
      While in emulation mode, a direct page addressing mode where
the index rolls out of direct page will wrap around to the beginning
of the direct page, just as a 6502 does.  For example:<br>
</p><pre><samp>
      LDX #$2C<br>
      LDA ($E0,X)<br>
</samp><br></pre>
<p>
Would yield an effective address of $0C and not $10C.
</p> <p>
     While in Native mode, a direct page addressing mode where the
index rolls out of direct page will wrap into the next page of
memory.  Using the example from above would yield the expected $10C
effect address.
</p> <p>
     For those old Commodore 128 programmers, the concept of a
relocatable Direct Page is nothing new - we've been tweaking it on
the MMU for years.  However; relocating zero page to something other
than a page boundary has some strong implications for the right style
of code.
</p> <p>
The power behind changing the direct page, is the same as 6502 zero
page addressing has always been.  You can save bytes by using direct
page addressing (zero page) modes and acquire faster execution times
as well.  It will take some time to find the best ways to program
with a relocated direct page, but once mastered, you wont get along
with out.<br>
</p>
<br><a href="#contents">TOC</a><br>
<pre>
<hr>
<hr>
<p><p>
=======================
<a name="6.00"><b>6.00 Addressing Modes </b></a>
=======================
</pre>
<p>
     All 6502 and 65C02 addressing modes and opcodes are supported
     in 65816 Native mode.  Nine other new addressing modes are also
     supported in both emulation and Native mode.  However; there
     are a few notable addressing differences between 816 Native
     mode and its 6502 counter part.
</p> <p>
     While in emulation mode there is no page wraparound when using
     Zero Page Indexed addressing from a base address+index that
     "rolls over" $FF.  While in Native 65816 mode indexes can be 16
     bits, so if the base address+index rolls over into the next
     page the proper effective address in generated.  With 16 bit
     index registers, a direct page addressing mode where indexing
     rolls over $FFFF the effective address roll back into the
     current bank not into the next bank (ie:lda $20,x where x is
     $FFFF will result in an effective address of $1F).
</p> <p>
     When using absolute indexed addressing where the base address
     is $FF01 to $FFFF an index value that would cause the eFFective
     address to roll over $FFFF would result in the next ram bank
     being accessed.  Whereas on a 6502 there would be a wrap around
     into zero page.
</p> <p>
     Remember that when index registers are 16 bit, that absolute
     indexed X or absolute indexed Y can now reach up to a full 64k!
     (ie: lda $6000,y where y=$2000 would result in an effective
     address of $8000).
</p> <p>
     The 85618 also fixed the 6502 indirect JMP bug.  A JMP ($12FF)
     now yields the proper address of $12FF-$1300.
</p>
<br><a href="#contents">TOC</a><br>
<pre>

<a name="6.10"><b>6.10 New 65816 Specific Addressing Modes:</b></a>
-----------------------------------------
<b>        New Mode Name                             Example</b>
        -------------------------------------------------------
        Program Counter Relative Long             BRL $1234
        Stack Relative                            LDA 15,S
        Stack Relative Indirect Indexed Y         LDA (9,S),Y
        Block Move                                MVP 0,0
        Absolute Long                             LDA $123456
        Absolute Long Indexed X                   LDA $123456,X
        Absolute Indexed Indirect                 JMP ($1234,X)
        Absolute Indirect Long                    JMP [$1234]
        Direct Page Indirect                      LDA ($12)
        Direct Page Indirect Long                 LDA [$12]
        Direct Page Indirect Long Indexed Y       LDA [$77],Y<br><br>


<a name="6.20"><b>6.20 Addressing Mode Descriptions</b></a><br>
----------------------------------<br>
</pre>
<b> Program Counter Relative Long: BRL #$44<br></b>
<p>
        Program Counter Relative Long extends the range of the
        branch instructions from the standard -127/+128 to 64k
        (+32767/-32768).  Thus; the operand of the BRL branch
        command is 16 bits.  This address mode will help enormously
        when writing relocatable code.<br>
</p>
<b>    Stack Relative:                            LDA 7,S<br></b>
<p>
        Stack Relative addressing uses the Stack Pointer as a base
        address and then adds the one byte user supplied operand as
        an offset into the stack.  The S specifies that this mode is
        Stack addressing via the stack pointer.<br>
</p> <p>
        When using Stack Relative Addressing you should keep in mind
        that the Stack Pointer will always point to the NEXT
        available spot on the stack.  Thus, an operand of one will
        retrieve the last item pushed onto the stack.  An operand of
        zero maybe useful to get another copy of the last thing
        PULLED off the stack - but, of course, if an interrupt hits,
        then you would be in trouble as the stack is manipulated via
        the interrupt routine.<br>
</p> <p>
<b> Stack Relative Indirect Indexed Y: LDA ($22,S),Y<br></b>
</p> <p>
         This addressing mode, locates and indirect address that
         points to the base data located elsewhere (same as zero
         page indirect indexed).  This two byte instruction starts
         with the current location of the stack, then adds the first
         operand, and finally adds in the Y index as and offset.<br>
</p> <p>
         The value of this addressing mode is that suppose you have
         an address you pushed onto the stack, by using this mode
         you can easily reach to where the data was located.<br>
</p><br>
<pre>
                10   LDY #0<br>
                20   LDA (1,S),Y   ; get the address 16 bits<br>
                30   TAX           ; save it in x<br>
                40   LDY #2<br>
                50   LDA (1,S),Y   ; get a second address<br>
</p> <p></pre>
         In the example above, we start with the current stack
         pointer location as the base address.  In line 20 we load
         from an offset of one (1,S) and then add in the offset to
         give the effective address.  The above assumes we are in 16
         bit index and 16 bit accumulator mode.<br>
</p> <p><pre>
<b>     Block Move:                               MVP 0,0<br></b>
</pre></p> <p>
         This is a major new addressing mode used by two
         instructions on the 65816.  The two new instructions Block
         Move Positive and Block Move Negative can move up to 64K of
         data from one memory location to another.  To setup a move,
         the accumulator is loaded with the number of bytes to copy,
         the X register is loaded with source address, and the Y
         register holds the destination address.  Then issue the
         Block move instruction and data is moved at 7 cycles per
         byte.<br>
</p> <p><pre>
<b>     Absolute Long:                            LDA $123456<br></b>
</pre></p> <p>

         Absolute Long is used to locate any data within the 16 bit
         address space of the 65816.  The operand is three bytes (24
         bits long).  The main usage of this addressing mode is to
         temporarily override the contents of the DBR Data Bank
         Register for the execution of the single instruction.  If
         standard absolute addressing is used, then the bank byte is
         concatenated to the address from the DBR.<br>
<pre></p> <p>
<b> Absolute Long Indexed X: LDA $123456,X<br></b>
</pre></p> <p>
          Absolute Long Indexed starts with the base operand and
          then adds the X index value to create an effective
          address.  This is the same as 6502 Absolute Indexed X,
          except the base operand is 24 bits wide.  Note that the
          actual order of bytes is Opcode, low byte, high byte, bank
          byte and that it is up to the assembler to arrange the
          bytes in this order.<br>
</p> <p><pre>
<b> Absolute Indexed Indirect JMP ($1234,X)<br></b>
</pre></p> <p>
          Absolute Indexed Indirect is a three byte instruction that
          creates the effective address by starting with the
          specified operand and then adding in the index value.  Old
          6502 programmers will recognize the following command
          lookup and execute example:<br>
<br></p><pre>
               SEC
               SBC "0"        ; subtract ascii zero off accumulator.
               ASL            ; times two into a table.
               TAX            ; into x as offset into word table.
               LDA TABLE,X    ; get command address byte.
               STA PTR        ; save in indirect pointer.
               LDA TABLE+1,X  ; get table command address high byte.
               STA PTR+1      ; save in pointer high byte.
               JMP (PTR)      ; jump to command.

               TABLE .WORD RUT1,RUT2,RUT3,...
               PTR   .BYTE 0,0

</pre>
<p>
Using Absolute Indexed Indirect addressing it could be written in half the
bytes and cycles:<br>

</p><pre>
               SEC
               SBC "0"        ; subtract ascii zero off accumulator.
               ASL            ; times two into a table.
               TAX            ; into x as index into word table.
               JMP (TABLE,X)  ; jump to command.

               TABLE .WORD RUT1,RUT2,RUT3,...
</pre>
<p>
A JMP Indexed Indirect [JMP ($1234,x)] assumes that the operand
address is in the current program bank.  A JMP indirect [JMP
($1234)] assumes that the operand address is in BANK ZERO.<br>
<p>
<pre>

<b>     Absolute Indirect Long                    JMP [$1234]</b><br>
</pre>
This addressing mode will form and effective address from the
location pointed to by the operand.<br>
<pre>

<b>     Direct Page Indirect                       LDA ($12)</b><br>
<p>
</pre>
This instruction is two bytes long.  The operand points to
a 16 bit Direct Page (zero page) pointer that will form
the effective address.  For example, if the Direct Page
pointer is $70, then the low byte with come from $70, and the
high byte from $71, and the Bank Byte from $72.  The bank
byte will be the current data bank register.<br>
<pre>
</p>
<b>     Direct Page Indirect Long                 LDA [$12]</b>
<p>
</pre>
This instruction is two bytes long.  The operand points to a 24 bit
Direct Page (zero page) pointer that will form the effective
address.  For example, if the Direct Page pointer is $70, then the
low byte with come from $70, the high byte from $71, and the Bank
Byte from $72.  The bank byte will temporarily override the data
bank register.<br>
</p>
<pre>
<b>     Direct Page Indirect Long Indexed Y       LDA [$77],Y<br></b>
<p>
</pre>
This instruction in two bytes long and allows you to temporarily
reach into any memory bank.  The operand is a direct page (zero
page) pointer.  The address located at the direct page offset is
three bytes long.  First is the low byte, then high byte, followed
by the bank byte of the base effect address.  The Y index register
is then added to this three byte destination address to form the
effective address.  Square brackets are used to denote that the
address is a full 24 bit address and not a simple 16 bit address.<br>
<pre>
<br><a href="#contents">TOC</a><br>
<p>
<hr>
<a name="7.00">7.00 <b>Interrupts</b></a>
---------------
</p> <p>
</pre>
     There are some quirks to 65816 interrupts that you should
consider.  If you are going to be writing native 65816 code you
should give some consideration to how your interrupt routine is going
to be handled.  If you have written custom a IRQ routine that
assumes Native mode, then your considerations are minor.  However,
if you are writing Native mode 65816 code with 16 bit accumulator
and/or 16 bit index registers, and you are using a stock kernal IRQ
that assumes emulation mode, then you must do some coding to handle
the discrepancies.  In 6502 emulation mode, and IRQ pushes the
program counter high, then pc low, and finally the status register
on to the stack.  When in Native mode an IRQ starts by stacking the
following:<br>
</p> <p>
<pre>
    Program Counter Bank (PBR)<br>
    Program Counter High<br>
    Program Counter Low<br>
    Status Register<br>
</pre></p> <p>
Next; the status register decimal mode bit (d) is cleared (setting
binary mode), and the IRQ flag is set (non NMI only).  Finally, the
program bank (PBR) is set to zero and the 65816 jumps through the
IRQ hardware vector.<br>
</p> <p>
The implications are that if the 65816 is running in emulation mode
in a ram bank other than Bank zero, then the program bank is going
to be lost (not good).  There are two solutions to the problem.  One
is never to run in emulation mode outside of Ram Bank zero.  Second;
you could save off the current program bank value somewhere in Ram
before running in emulation mode beyond Bank Zero.<br>
</p> <p>
One thing that is unclear at this point, is if the CMD Super CPU can
even handle a Native Mode IRQ.  Native Mode features a new hardware
vector table:<br>
</p> <p>
<br><a href="#contents">TOC</a><br>
<pre>
<a name="7.10"><b>7.10 Hardware Vectors:</b></a>
----------------------
<b>     Native Mode           6502 Emulation Mode</b>
     -----------------------------------------
     IRQ   $FFEE-$FFEF     IRQ/BRK $FFFE-$FFFF
                           RESET   $FFFC-$FFFD
     NMI   $FFEA-$FFEB     NMI     $FFFA-$FFFB
     ABORT $FFE8-$FFE9     ABORT   $FFF8-$FFF9
     BRK   $FFE6-$FFE7
     COP   $FFE5-$FFE6     COP     $FFF4-$FFF5
</p> <p></pre>

Notice that there is a separate BRK vector for Native mode, and no
need to poll bit 5 for the brk flag.  However when running in
emulation mode, remember that bit 5 is still the BRK flag, and your
IRQ will still need to check for the source of the IRQ.
</p> <p>
While in Native mode, a BRK instruction is two bytes.  The Zero BRK
opcode followed by an optional "signature" byte.  This way, you can
detect what BRK caused the vector to be taken for multiple BRK's
while debugging.
</p> <p>
COP is for a coprocessor interrupt. (see the instruction COP)
</p> <p>
Notice in Native mode where the IRQ vector destinations are...hmm
</p> <p>
When an IRQ is triggered, the current instruction is completed
before the interrupt is processed.  This "interrupt latency" may be
up to 7 clock cycles.  If you are running a time critical IRQ you
may want to examine the WAI:wait for interrupt instruction whereby
you can stop the processor until and interrupt occurs.
</p> <p>
The ABORT vector listed above is taken when the 65816's Abort pin is
pulled low.  This pin is only available on the 65816.
</p> <p><br>
<br><a href="#contents">TOC</a><br>
<pre>
<hr>
<hr>
================================
<a name="appena"><b><h1>Appendix A: 65816 Instruction Set</h1></b></a>
================================
<hr><hr>
<b>Syntax Conventions:</b>

   addr              two byte address.
   addr/const        two byte value: either an address or a constant.
   const             one- or two-byte constant.
   destbk            64k bank to which string will be moved.
   dp                one-byte direct page offset (6502 zero page).
   label             label of code in same 64K bank as instruction.
   long              three-byte address (includes bank byte)
   nearlabel         label of code close enough to instruction to be
                     reachable by a one-byte signed offset.
   sr                one-byte stack relative offset.
   srcebk            64k bank from which string will be moved.


   Flags
   Bits         76543210
                nvmxdizc
                       e

                n - negative.
                v - overflow.
                m - 8/16 memory/accumulator.
                x - 8/16 bit index registers.
                d - decimal mode.
                i - irq enable disable.
                z - zero result.
                c - carry.
                e - emulation.
<hr>

<b>ADC  Add with carry.</b>
</pre>
<p>
When using 16 bit accumulator mode, as expected, a carry will be
properly rolled over from bit 7 to bit 8 when generated by the
operation.  (ie: $FF+4 = $0103 with 1 in high byte an 3 in low byte
of the accumulator.) Thus carry need only be cleared when the low
order bytes are added.  Manual checking for carry above bit 15 will
still have to be done just as when in 8 bit accumulator mode.<br>
</p> <p>
When in 16 bit mode, the low-order bits are located in the effective
address, and the high order bits are located in the effective
address plus one.<br>
</p>
<pre>

     Flags Altered nv----zc
                   n Set if most-significant bit of result is set.
                   v Set if signed overflow.
                   z Set if result is zero.
                   c Set if overflow.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                     ADC #const     69      2*      2 | 1
  Absolute                      ADC addr       6D      3       4 | 1
  Absolute Long                 ADC long       6F      4       5 | 1
  Direct Page                   ADC dp         65      2       3 | 1,2
  Direct Page Indirect          ADC (dp)       72      2       5 | 1,2
  Direct Page Indirect Long     ADC [dp]       67      2       6 | 1,2
  Absolute Indexed,X            ADC addr,X     7D      3       4 | 1,3
  Absolute Long Indexed,X       ADC long,X     7F      4       5 | 1
  Absolute Indexed,Y            ADC addr,Y     79      3       4 | 1,3
  Direct Page Indexed,X         ADC dp,X       75      2       4 | 1,2
  DP Indexed Indirect,X         ADC (dp,X)     61      2       6 | 1,2
  DP Indirect Indexed,Y         ADC (dp),Y     71      2       5 | 1,2,3
  DP Indirect Long Indexed,Y    ADC [dp],Y     77      2       6 | 1,2
  Stack Relative                ADC sr,S       63      2       4 | 1
  SR Indirect Indexed,Y         ADC (sr,S),Y   73      2       7 | 1
-----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if adding index crosses a page boundary.



<b>AND And Accumulator with Memory</b>

    Logically ANDs the data located at the effective address
    specified by the operand and the accumulator.
    If in 16 bit accumulator mode (m=0) Data ANDed from memory is
    16 bits wide, the low byte is the effective address and the high
    byte is the effective address+1.

     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result of and is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    AND #const     29      2*      2 | 1
  Absolute                     AND addr       2D      3       4 | 1
  Absolute Long                AND long       2F      4       5 | 1
  Direct Page                  AND dp         25      2       3 | 1,2
  Direct Page Indirect         AND (dp)       32      2       5 | 1,2
  DP Indirect Long             AND [dp]       27      2       6 | 1,2
  Absolute Indexed,X           AND addr,X     3D      3       4 | 1,3
  Absolute Long Indexed,X      AND long,X     3F      4       5 | 1
  Absolute Indexed,Y           AND addr,Y     39      3       4 | 1,3
  Direct Page Indexed,X        AND dp,X       35      2       4 | 1,2
  DP Indexed Indirect,X        AND (dp,X)     21      2       6 | 1,2
  DP Indirect Indexed,Y        AND (dp),Y     31      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   AND [dp],Y     37      2       6 | 1,2
  Stack Relative (SR)          AND sr,S       23      2       4 | 1
  SR Indirect Indexed,Y        AND (sr,S),Y   33      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
   3 Add 1 cycle if adding index crosses a page boundary.



<b>ASL Arithmetic Shift Left</b>

    Shifts all bits left with most significant bit moving into the
    carry flag.  If in 16 bit accumulator mode (m=0), data shifted
    is 16 bits.

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c High bit (7 or 15) is moved into carry.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ASL a          0A      1       2 |
  Absolute                     ASL addr       0E      3       6 | 1
  Direct Page                  ASL dp         06      2       5 | 1,2
  Absolute Indexed,X           ASL addr,X     1E      3       7 | 1
  Direct Page Indexed,X        ASL dp,X       16      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.


<br><a href="#contents">TOC</a><br>

<b>Branching Instructions:</b>
-----------------------
</pre><p>
The following branch instructions work identically to a 6502 -
therefore, no indepth discussion will be presented.<br>
Branching commands do not affect any status register flags.
The single byte operand range is +128 to -127.<br>
</p><pre>
        BCC Branch Carry Clear     alias BLT Branch Less Than.
        BCS Branch Carry Set       alias BGE Branch Greater Than or Equal.
        BEQ Branch Equal
        BNE Branch Not Equal
        BMI Branch Result Minus
        BPL Branch Result Positive
        BVC Branch Overflow Clear
        BVS Branch Overflow Set

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Program Counter Relative     BCC near       90      2       2 | 1,2
  Program Counter Relative     BCS near       B0      2       2 | 1,2
  Program Counter Relative     BEQ near       F0      2       2 | 1,2
  Program Counter Relative     BNE near       D0      2       2 | 1,2
  Program Counter Relative     BMI near       30      2       2 | 1,2
  Program Counter Relative     BPL near       10      2       2 | 1,2
  Program Counter Relative     BVC near       50      2       2 | 1,2
  Program Counter Relative     BVS near       70      2       2 | 1,2
----------------------------------------------------------------------
   1 Add 1 cycle if branch is taken.
   2 Add 1 more cycle if in 6502 emulation mode (e=1).


<br><a href="#contents">TOC</a><br>

<b>New Branch Instructions:</b>
------------------------

<b>BRA Branch Always</b>
</pre><p>
    Branch always takes the operand branch without regard for the
    current state of the status register.  The single byte operand
    range is +128 to -127.  This instruction and the following BRL
    instruction ease the task of writing relocatable code.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Program Counter Relative     BRA near       80      2       3 | 1
----------------------------------------------------------------------
    2 Add 1 more cycle if in 6502 emulation mode (e=1).



<b>BRL   Branch Always Long</b>
</pre><p>
     Same as BRA, but the operand is 2 bytes giving the instruction
     a 64k range.  This instruction is similar to the JMP command,
     with the advantage being that JMP is and absolute address and
     BRL is a relative address.<br>
     No flags are affected.<br>
</p><pre>


Addressing Mode              Syntax        Opcode   Bytes  Cycles
-----------------------------------------------------------------
  Program Counter Relative Long BRL $xxxx     82      3       4
-----------------------------------------------------------------



<b>BIT  Test Memory Bits against Accumulator</b>
</pre><p>
     The 65816 provides 3 new addressing modes for the old standard
     BIT instruction.  The only true difference is that when the
     processor is in 16 bit mode, the top two bits xfered to the
     status register will come from bits 14 and 15.  When in 8 bit
     mode bits 6 and 7 are xfered to the status register.<br><br>
</p><pre>

     Flags affected nv----z-  (Other than immediate addressing).
                    ------z-  (Immediate addressing only).
                    n Takes value of most significant bit of memory data.
                    v Takes value from bit 6 or 14 of memory data.
                    z Set if logical AND of mem and acc is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    BIT #const     89      2*      2 | 1
  Absolute                     BIT addr       2C      3       4 | 1
  Direct Page                  BIT dp         24      2       3 | 1,2
  Absolute Indexed,X           BIT addr,X     3C      3       4 | 1,3
  Direct Page Indexed,X        BIT dp,X       34      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if adding index crosses a page boundary.



<b>BRK Software Break</b>
</pre><p>
    While in native 65816 mode, BRK is unaffected by the I interrupt
    disable flag.  Additionally, you may now pass a one byte
    signature byte to indicate which BRK instruction caused the BRK
    to be preformed.<br>
    The new BRK handler includes a Hardware Vector- thus, it is no
    longer required to check for the BRK bit flag via the IRQ.<br>
</p> <p>
    When a BRK is performed in 65816 Native mode:<br>
</p><pre>
<ul>
     <li>the program counter bank register is pushed onto stack.
     <li>the program counter is incremented by two and pushed on the stack.
     <li>the status register is pushed onto the stack
     <li>the interrupt disable flag is set.
     <li>the decimal mode flag is cleared.
     <li>the program bank register is cleared to zero.
     <li>the program counter is loaded from the break vector at $FFE6-$FFE7.
</ul></pre>
<p>
    While in 6502 emulation mode, (e=1) a BRK is preformed true to
    it's 6502 forerunner (b flag set, status pushed onto stack, SEI
    and IRQ performed.).<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack/Interrupt              BRK            00      2*      7 | 1
----------------------------------------------------------------------
  * BRK is one byte, but program counter value pushed onto stack is
    incremented by 2 allowing for optional signature byte.
  1 Add one cycle for 65816 native mode (e=0).



<b>Status Register Setting and Clearing:</b>
-------------------------------------
</pre><p>
The following status set and reset instructions operate the same in
65816 native mode and 6502 emulation mode.<br>
</p><pre>
      <b>CLC</b>  Clear carry flag.
      <b>CLD</b>  Clear decimal flag.
      <b>CLI</b>  Clear interrupt flag.
      <b>CLV</b>  Clear overflow flag.
      <b>SEC</b>  Set carry flag.
      <b>SED</b>  Set decimal flag.
      <b>SEI</b>  Set interrupt flag.

                 Flags
Addressing Mode nvmxdizc     Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied       -------0      CLC            18      1       2
  Implied       ----0---      CLD            D8      1       2
  Implied       -----0--      CLI            58      1       2
  Implied       -0------      CLV            B8      1       2
  Implied       -------1      SEC            38      1       2
  Implied       ----1---      SED            F8      1       2
  Implied       -----1--      SEI            78      1       2
----------------------------------------------------------------------


<br><a href="#contents">TOC</a><br>

<b>CMP Compare Accumulator with Memory</b>
</pre><p>
    For the most part, this instruction works the same in 6502
    emulation mode and 65816 mode.<br>
    While in 16 bit accumulator mode the low byte of the compare
    will come from the effective address and the high byte from the
    effective address plus one.<br>
</p><pre>

     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required. Acc =&gt; memory.
                     C=0 if borrow required Acc &lt; memory.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CMP #const     C9      2*      2 | 1
  Absolute                     CMP addr       CD      3       4 | 1
  Absolute Long                CMP long       CF      4       5 | 1
  Direct Page                  CMP dp         C5      2       3 | 1,2
  Direct Page Indirect         CMP (dp)       D2      2       5 | 1,2
  Direct Page Indirect Long    CMP [dp]       C7      2       6 | 1,2
  Absolute Indexed,X           CMP addr,X     DD      3       4 | 1,3
  Absolute Long Indexed,X      CMP long,X     DF      2       7 | 1
  Absolute Indexed,Y           CMP addr,Y     D9      3       4 | 1,3
  Direct Page Indexed,X        CMP dp,X       D5      2       4 | 1,2
  DP Indexed Indirect,X        CMP (dp,X)     C1      2       6 | 1,2
  DP Indirect Indexed,Y        CMP (dp),Y     D1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   CMP [dp],Y     D7      2       6 | 1,2
  Stack Relative (SR)          CMP sr,S       C3      2       4 | 1
  SR Indirect Indexed,Y        CMP (sr,S),Y   D3      2       7 | 1
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if adding index crosses a page boundary.



<b>COP Coprocessor Empowerment</b>
</pre><p>
   COP cause a software interrupt through a separate COP hardware
   vector.  The vector is to be located at $FFF$-$FFF5.  In 6502
   emulation mode:
</p> <p><ul>
     <li>The program counter is incremented by 2 and pushed on stack.
     <li>The status register is pushed onto the stack.
     <li>The interrupt status bit is set.
     <li>The program counter is loaded with the hardware vector.
     <li>The decimal flag is cleared.<br>
</ul></p>
<b>   In Native mode:</b>
<p><ul>
     <li>The PC bank register is pushed onto stack.
     <li>The PC is incremented by two and pushed onto stack.
     <li>The status register is pushed onto stack.
     <li>The interrupt status flag is set.
     <li>The program bank register is cleared to zero.
     <li>The PC is loaded with the hardware vector.
     <li>The decimal flag is cleared after COP executed.
</ul><p><pre>
     Flags Altered ----di--
                   d decimal mode flag is reset to zero.
                   i Interrupt disable is set.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack/Interrupt              COP const      02      2**     7 | 1
----------------------------------------------------------------------
  * COP is a 1 byte instruction, but the PC in incremented by to and
    pushed onto stack, allowing for an optional signature byte.
  1 Add 1 cycle for 65816/65802 native mode (e=0)



<b>CPX Compare X Index register with Memory</b>
</pre><p>
    CPX functions the same as a 6502.  The only notable exception
    is to remember that when in 16 bit index register mode (x=0)
    that date/memory will be 16 bits wide.  The low order byte will
    come from the the effect address and the high order byte from
    the effective address plus one.<br>
<p><pre>
     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required ( X &gt;= memory).
                     Cleared if borrow required (X &lt; memory).

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CPX #const     E0      2*      2 | 1
  Absolute                     CPX addr       EC      3       4 | 1
  Direct Page                  CPX dp         E4      2       3 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.



<b>CPY Compare Y Index register with Memory</b>
</pre><p>
    CPY functions the same as a 6502.  The only notable exception
    is to remember that when in 16 bit index register mode (x=0)
    that date/memory will be 16 bits wide.  The low order byte will
    come from the the effect address and the high order byte from
    the effective address plus one.<br>
</p><pre>
     Flags Altered n-----zc
                   n Set if most significant bit of result is set.
                   z Set if result is zero.
                   c Set if no borrow was required ( Y &gt;= memory).
                     Cleared if borrow required (Y &lt; memory).


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    CPY #const     C0      2*      2 | 1
  Absolute                     CPY addr       CC      3       4 | 1
  Direct Page                  CPY dp         C4      2       3 | 1,2
----------------------------------------------------------------------
    * Add 1 byte if m=0 (16-bit index registers).
    1 Add 1 cycle if x=0 (16-bit index registers).
    2 Add 1 cycle if low byte of Direct Page register is &lt;&gt; 0.
<p>
</p>
<b>DEC Decrement Memory</b>
</pre><p>
    DEC also works nearly the same as a 6502 mode.  When in 16 bit
    accumulator/memory mode (m=0) data altered will be 16 bits wide
    with automatic underflow from high byte to low byte.  The low
    order byte will come from the the effect address and the high
    order byte from the effective address plus one.<br>
<p><pre>
     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  DEC A          3A      1       2 |
                        Alias: DEA
  Absolute                     DEC addr       CE      3       6 | 1
  Direct Page                  DEC dp         C6      2       5 | 1,2
  Absolute Indexed,X           DEC addr,X     DE      3       7 | 1
  Direct Page Indexed,X        DEC dp,X       D6      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
<br>

<b>DEX, DEY Decrement Index Registers</b>
</pre><p>
    Both instructions operate just as a 6502.  When in 16 bit index
    register mode, the register will be treated as 16 bits wide.<br>
<p><pre>
     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      DEX            CA      1       2
  Implied                      DEY            88      1       2
----------------------------------------------------------------------



<b>EOR Exclusive-OR Accumulator with Memory</b>
</pre><p>
    Another instruction that operates just as a 6502, only new
    addressing modes.  When in 16 bit memory/accumulator mode data
    is 16 bits wide - as usual the low byte will come from the
    effective address and the high byte from the effective address
    plus one.<br>
</p><pre>
     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    EOR #const     49      2*      2 | 1
  Absolute                     EOR addr       4D      3       4 | 1
  Absolute Long                EOR long       4F      4       5 | 1
  Direct Page                  EOR dp         45      2       3 | 1,2
  Direct Page Indirect         EOR (dp)       52      2       5 | 1,2
  Direct Page Indirect Long    EOR [dp]       47      2       6 | 1,2
  Absolute Indexed,X           EOR addr,X     5D      3       4 | 1,3
  Absolute Long Indexed,X      EOR long,X     5F      4       5 | 1
  Absolute Indexed,Y           EOR addr,Y     59      3       4 | 1,3
  Direct Page Indexed,X        EOR dp,X       55      2       4 | 1,2
  DP Indexed Indirect,X        EOR (dp,X)     41      2       6 | 1,2
  DP Indirect Indexed,Y        EOR (dp),Y     51      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   EOR [dp],Y     57      2       6 | 1,2
  Stack Relative (SR)          EOR sr,S       43      2       4 | 1
  SR Indirect Indexed,Y        EOR (sr,S),Y   53      2       7 | 7
----------------------------------------------------------------------
    * Add 1 byte if m=0 (16-bit memory/accumulator).
    1 Add 1 cycle if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
    3 Add 1 cycle if adding index crosses a page boundary.



<b>INC Increment Data</b>
</pre><p>
    Also operates just as the 6502 INC instruction.  When in 16 bit
    memory/accumulator mode (m=0) data acted upon is 16 bits wide.<br>
    One new addressing mode is Accumulator addressing that will
    increment the Accumulator.<br>
<p><pre>
     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  INC a          1A      1       2 |
                        Alias: INA
  Absolute                     INC addr       EE      3       6 | 1
  Direct Page                  INC dp         E6      2       5 | 1,2
  Absolute Indexed,X           INC addr,X     FE      3       7 | 1
  Direct Page Indexed,X        INC dp,X       F6      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.


<b>INX, INY  Increment Index Registers</b>
</pre><p>
    Both instructions operate just as a 6502.  When in 16 bit index
    register mode, the register will be treated as 16 bits wide.<br>
</p><pre>
     Flags Altered n-----z-
                   n Set if most significant bit of result is set.
                   z Set if result is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Implied                      INX            E8      1       2 |
  Implied                      INY            C8      1       2 |
----------------------------------------------------------------------



<b>JMP Jump to New Location</b>
</pre><p>
      JMP transfers control to the operand address. If a long
      jump is executed the program counter bank register is loaded
      with the third byte of the target address.<br>
</p> <p>
      The 65816 Designers also specify that an assembler could
      possibly use JML in place of a JMP Long instruction, and also
      JML [adr] for Absolute indirect long.<br>
</p><pre>
        Flags Affected:--------



Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     JMP addr       4C      3       3 |
  Absolute Indirect            JMP (addr)     6C      3       5 | 1
  Absolute Indexed Indirect    JMP (addr,X)   7C      3       6 |
  Absolute Long                JMP long       5C      4       4 |
                        Alias: JML long
  Absolute Indirect Long       JMP [addr]     DC      3       6 |
                        Alias: JML [addr]
----------------------------------------------------------------------
    1 6502: If low byte of addr is $FF (ie: addr is $xxFF) yields
      incorrect result.



JSR, JSL Jump to Subroutine (gosub)
</pre>
<p>
     JSR works just as a 6502 with the new addressing modes available.
     If an absolute address is coded by the assembler that is less
     than $FFFF then a standard JSR is used, else if it is greater
     than $FFFF then absolute long addressing is used.  A standard
     JSR gosubs to the the routine in the current program bank.<br>
</p>
<p>
     JSR can also use Indexed Indirect addressing.  (see section on
     addressing modes for an example.)<br>
</p>
<p>
     JML is a four byte instruction that will JSR to a subroutine
     located in any bank.  When executed the current program counter
     bank is pushed onto the stack before the program counter
     high/low bytes.<br>
<p>
<pre>
         Flags Affected: --------

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Absolute Long                JSL long       22      4       8
                        Alais: JSR long
  Absolute                     JSR addr       20      3       6
  Absolute Indexed Indirect    JSR (addr,X)   FC      3       8
----------------------------------------------------------------------



<b>LDA Load the Accumulator with Memory</b>
</pre><p>
LDA is nearly identical to the standard 6502 LDA instruction.
New features are the implementation of the new addressing modes.
While the status register is set for 16 bit memory/accumulator
mode (m=0), data loaded is 16 bits wide with the load byte
coming from the effective address and the high byte of the
accumulator coming from the effective address plus one.<br>
<p><pre>
     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDA #const     A9      2*      2 | 1
  Absolute                     LDA addr       AD      3       4 | 1
  Absolute Long                LDA long       AF      4       5 | 1,2
  Direct Page                  LDA dp         A5      2       3 | 1,2
  Direct Page Indirect         LDA (dp)       B2      2       5 | 1,2
  Direct Page Indirect Long    LDA [dp]       A7      2       6 | 1,2
  Absolute Indexed,X           LDA addr,X     BD      3       4 | 1,3
  Absolute Long Indexed,X      LDA long,X     BF      4       5 | 1
  Absolute Indexed,Y           LDA addr,Y     B9      3       4 | 1,3
  Direct Page Indexed,X        LDA dp,X       B5      2       4 | 1,2
  DP Indexed Indirect,X        LDA (dp,X)     A1      2       6 | 1,2
  DP Indirect Indexed,Y        LDA (dp),Y     B1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   LDA [dp],Y     B7      2       6 | 1,2
  Stack Relative (SR)          LDA sr,S       A3      2       4 | 1
  SR Indirect Indexed,Y        LDA (sr,S),Y   B3      2       7 | 1
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit memory/accumulator).
  1 Add 1 cycle if m=0 (16-bit memory/accumulator).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if adding index crosses a page boundary.<br>



<b>LDX Load X Register from Memory</b>
</pre><p>
    LDX is identical to a stock 6502.<br>
    The only new feature to remember is that when in 16 bit index
    register mode (x=0) that data will be 16 bits wide.  The X
    register low byte will come from the effective address and the
    high byte from the effective address plus one.<br>
<p><pre>
     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDX #const     A2      2*      2 | 1
  Absolute                     LDX addr       AE      3       4 | 1
  Direct Page                  LDX dp         A6      2       3 | 1,2
  Absolute Indexed,Y           LDX addr,Y     BE      3       4 | 1,3
  DP Indexed,Y                 LDX dp,Y       B6      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if indexing crosses page boundary.



<b>LDY Load Y Register from Memory</b>
</pre><p>
    LDY is identical to a stock 6502.<br>
    The only new diversion is to remember that when in 16 bit index
    register mode (x=0) that data will be 16 bits wide.  The Y
    register low byte will come from the effective address and the
    high byte from the effective address plus one.<br>
</p><pre>
     Flags affected n-----z-
                    n Takes value of most significant bit of memory data.
                    z Set if data loaded is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    LDY #const     A0      2*      2 | 1
  Absolute                     LDY addr       AC      3       4 | 1
  Direct Page                  LDY dp         A4      2       3 | 1,2
  Absolute Indexed,X           LDY addr,X     BC      3       4 | 1,3
  Direct Page Indexed,X        LDY dp,X       B4      2       4 | 1,2
----------------------------------------------------------------------
  * Add 1 byte if m=0 (16-bit index registers).
  1 Add 1 cycle if x=0 (16-bit index registers).
  2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
  3 Add 1 cycle if indexing crosses page boundary.



<b>LSR Logical Shift Right.</b>
</pre><p>
    Yet another instruction unchanged from the standard 6502
    instruction set.<br>
    16 bit mode (m=0) data shifted will be 16 bits wide.<br>
</p><pre>
     Flags Altered n-----zc
                   n Cleared.
                   z Set if result is zero.
                   c Bit zero becomes new carry.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  LSR a          4A      1       2 |
  Absolute                     LSR addr       4E      3       6 | 1
  Direct Page                  LSR dp         46      2       5 | 1,2
  Absolute Indexed,X           LSR addr,X     5E      3       7 | 1
  Direct Page Indexed,X        LSR dp,X       56      2       6 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if m=0 (16-bit memory/accumulator).
    2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.



<b>Block Move Instructions</b>
=======================

<b>MVP Move Positive destination &gt; source</b>
<b>MVN Move Negative destination &lt; source</b>
</pre><p>
     This instruction is new 65816 only.  MVN and MVP move data
     from memory location to memory location without user
     intervention.<br>
</p> <p>
     Two instructions are necessary so that as the data is being
     moved in a negative direction it will not overwrite itself.<br>
</p> <p>
     The source address for the move is taken from the X register.
     The destination address for the move is taken for the Y register.
     The 16 bit length of the move is taken from the Accumulator
     regardless of the m flag setting.  This value should be one
     less than the actual length of the move (ie a=$0000 and one
     byte will be moved).<br>
</p> <p>
     The two operand bytes specify the source bank of 64k and the
     destination bank of 64k.  The assembler order of the operand
     bytes is source, destination - however, the actual binary
     output code will be the MVN or MVP opcode followed byte the
     destination bank byte and the source bank byte.<br>
</p> <p>
     MVN Move Negative is used when the source address is greater
     than the destination address, or conversely when the
     destination range is lower than the source range.<br>
</p> <p>
     The MVN instruction uses the X and Y registers to denote the
     bottom (beginning) address of the two memory segments to be
     moved.  With MVN the data is moved from the source in X to the
     destination in Y, then the X and Y registers are are
     incremented and the accumulator decremented until the
     accumulator underflows to $FFFF.<br>
</p> <p>
     MVP Move Positive is used with the source address is less than
     the destination, or conversely when the destination range is
     higher in memory than the source range.<br>
</p> <p>
     The MVP instruction uses the X and Y registers to denote the
     top address of the two blocks of memory.  The data is moved
     from the source in X to the address in Y and then the XY and
     accumulator registers are decremented until the accumulator
     underflows to $FFFF.<br>
</p> <p>
     If the index registers are set for 8 bit mode (x=1) or the
     processor is set for 6502 emulation mode, then the
     data moved will be in page zero only because the high bytes
     will default to zero.<br>
</p> <p>
     To reduce code length it is very easy to setup the move
     instructions in a subroutine, then use dynamically modified code
     to exchange the MVN and MVP opcodes on-the-fly.<br>
</p> <p>
     Status register flags are NOT affect by the move instructions.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Block Move                   MVN src,dest   54      3      *
  Block Move                   MVP src,dest   44      3      *
----------------------------------------------------------------------
   * 7 cycles each byte moved.

<br><a href="#contents">TOC</a><br>


<b>NOP No Operation.</b>
</pre><p>
    Same as 6502. No flags are affected with NOP.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      NOP            EA      1       2
----------------------------------------------------------------------



<b>ORA OR Accumulator with Memory.</b>
</pre><p>
    Same function as 6502 ORA with new addressing modes.<br>
    When in 16 bit memory/accumulator mode (m=0) data acted upon is
    16 bits wide.  The low byte is the effective address and the
    high byte is the effective address plus one.<br>
</p><pre>
    Flags Affected: n-----z-
                    n Set if most significant bit of result is set.
                    z Set if result is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    ORA #const     09      2*      2 | 1
  Absolute                     ORA addr       0D      3       4 | 1
  Absolute Long                ORA long       0F      4       5 | 1
  Direct Page                  ORA dp         05      2       3 | 1,2
  Direct Page Indirect         ORA (dp)       12      2       5 | 1,2
  Direct Page Indirect Long    ORA [dp]       07      2       6 | 1,2
  Absolute Indexed,X           ORA addr,X     1D      3       4 | 1,3
  Absolute Long Indexed,X      ORA long,X     1F      4       5 | 1
  Absolute Indexed,Y           ORA addr,Y     19      3       4 | 1,3
  Direct Page Indexed,X        ORA dp,X       15      2       4 | 1,2
  DP Indexed Indirect,X        ORA (dp,X)     01      2       6 | 1,2
  DP Indirect Indexed,Y        ORA (dp),Y     11      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   ORA [dp],Y     17      2       6 | 1,2
  Stack Relative (SR)          ORA sr,S       03      2       4 | 1
  SR Indirect Indexed,Y        ORA (sr,S),Y   13      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
   3 Add 1 cycle if adding index crosses a page boundary.



<b>PEA Push Effective Absolute Address</b>
</pre><p>
    PEA pushes the sixteen-bit operand onto the stack.  The stack
    pointer is decremented by two.  No flags are affected.  Unlike
    other instructions that use similar assembler notations, PEA
    pushes the value of the operands onto the stack, NOT the data
    located at an effective address.  A more appropriate name should
    have been to push Immediate data onto the stack - it is unclear
    why this discrepancy exists.<br>
</p><pre>
    For example:

               PEA $1234
</pre><p>
        Pushes a #$12 and then a #$34 onto the stack.
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Absolute)             PEA addr      F4      3       5
----------------------------------------------------------------------



<b>PEI Push Effective Indirect Address</b>
</pre><p>
    This 65816 instruction pushes the address of the effective
    address onto the stack.  This instruction always pushes 16 bits
    of data onto the stack without regard for the settings of the x
    and m status bits.<br>
</p> <p>
    The address of the effective address plus one is pushed on the
    stack first and then the address of the effective address is
    pushed on second.<br>
</p> <p>
    For example: suppose $5678 is stored at location $21/$22 in
    standard low byte/high byte format, then a<br>
</p><pre>
         PEI ($21)<br>
</pre></p> <p>
    would get the $5678 from $21/$22 and push it onto the stack.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack (Direct Page Indirect) PEI (dp)      D4       2       6 | 1
----------------------------------------------------------------------
   1 Add 1 cycle if low byte of direct page is &lt;&gt;0.



<b>PER Push effective PC Relative Indirect Address</b>
</pre><p>
    This instruction takes the program counter and adds the 16 bit
    operand and pushes the resulting 16 bits onto the stack.  The
    destination address must be located within the current bank of
    64k memory.  The value of the program counter used in the
    calculation is the address of the NEXT instruction following the
    PER and two operand bytes.<br>
</p> <p>
    The result high byte is pushed first, followed by the low byte
    of the result.<br>
</p> <p>
    Because this instruction uses a relative offset for the operand,
    it can aid in writing relocatable code.  One could envision
    pushing an unknown run-time address onto the stack with PER and
    then pulling the address off to determine the programs run time
    origin.<br>
</p> <p>
    Another use of this instruction could be to push a return
    address onto the stack for 6502 pha:pha:rts style coding<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (PC Relative Long)   PER label       62      3       6
----------------------------------------------------------------------



<b>Push, Pull APXY Instructions</b>
</pre><p>
      PHA,PHP,PLA,PLP are unchanged from their 6502 forerunners.
      The only notable difference is that 16 bits will be pushed on
      when in accumulator/memory (m=0) mode and a PHA or PLA is
      executed (PHP/PLP only operate on 8 bits).<br>
</p> <p>
      New push and pull stack instructions include PHY,PLY,PHX,PLX.
      These four new instructions push and pull the index registers
      on and off the stack.  When the status register is set to 16
      bit index register mode (x=0), the pull and push index
      registers will operate on 16 bits when the status register x
      is set to 0.<br>
</p><pre>

Addressing Mode   Flags      Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Push)   --------      PHA            48      1       3 | 1
  Stack (Push)   --------      PHP            08      1       3 |
  Stack (Push)   --------      PHX            DA      1       3 | 2
  Stack (Push)   --------      PHY            5A      1       3 | 2
  Stack (Pull)   n-----z-      PLA            68      1       4 | 1
  Stack (Pull)   nvmxdizc      PLP            28      1       4 |
  Stack (Pull)   n-----z-      PLX            FA      1       4 | 2
  Stack (Pull)   n-----z-      PLY            7A      1       4 | 2
----------------------------------------------------------------------
   1 Add 1 cycle if 16 bit accumulator/memory mode (m=0).
   2 Add 1 cycle if 16 bit index registers (x=0).



<b>Push, Pull Bank Registers</b>
</pre><p>
   PHB Pushes the 8 bit contents of the data bank register on the stack.<br>
</p> <p>
   PHD Pushes the 16 bit contents of the direct page register on stack.<br>
       The high byte is pushed first, followed by the low byte.<br>
</p> <p>
   PHK Pushes the 8 bit contents of the program bank register on stack.<br>
</p> <p>
   PLB Pulls a byte off the stack into the data bank register.
       This is the only instruction that can directly change the
       data bank register.<br>
</p> <p>
   PLD Pulls a sixteen bit value off stack into the direct page
       register.  The low byte is pulled first, followed by the high
       byte.<br>
</p> <p>
   Pulled Flags Affected by pull instructions:
</p><pre>
             n Set if most significant bit of value pulled is set.
             z Set if value pulled is zero.


Addressing Mode   Flags      Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (Push)                 PHB            8B      1       3
  Stack (Push)                 PHD            0B      1       4
  Stack (Push)                 PHK            4B      1       3
  Stack (Pull)   n-----z-      PLB            AB      1       4
  Stack (Pull)   n-----z-      PLD            2B      1       5
----------------------------------------------------------------------



<b>REP Reset Status Bits.</b>
</pre><p>
    REP is a new 65816 instruction.  When used, it will reset
    (clear) the bits specified by the 1 byte immediate value.<br>
</p> <p>
    For Example to clear bit 5 of the status register:<br>
</p> <p>
<br>       REP #%00100000   ;clear bit 5.
</p> <p>
       or to clear multiple bits:<br>
</p> <p>
<br>       REP #%10110000   ;clear 7,5 and 4.
</p> <p>
    Any combination is acceptable.<br>
</p> <p>
    To set a bit, see SEP.<br>
</p><pre>

    Flags affected: nvmxdizc
                 All flags that have an operand bit set are cleared.
                 Other flags are not affected.

Addressing Mode               Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Immediate                    REP #const     C2      2       3
----------------------------------------------------------------------


<b>ROL Rotate Memory or Accumulator Left</b>
</pre><p>
    ROL works same as the 6502 ROL instruction.<br>
    When in 16 bit accumulator/memory mode (m=0) Data rotated is 16
    bits wide with the former bit 15 becoming the new carry.  - the
    low-order bits are located in the effective address, and the
    high order bits are located in the effective address plus one.<br>
</p><pre>

    Flags affected: n-----zc
                    n Set if most significant bit of result is set.
                    z Set if result is zero.
                    c The high bit (7 or 15) becomes the new carry.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ROL A          2A      1       2 |
  Absolute                     ROL addr       2E      3       6 | 1
  Direct Page                  ROL dp         26      2       5 | 1,2
  Absolute Indexed,X           ROL addr,X     3E      3       7 | 1
  Direct Page Indexed,X        ROL dp,X       36      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if 16 bit memory accumulator mode (m=0).
   2 Add 1 cycle if direct page pointer is &lt;&gt;0.



<b>ROR Rotate Memory or Accumulator Right.</b>
</pre><p>
    Works as 6502 ROR expected.<br>
    When in 16 bit memory/accumulator mode (m=0) data rotated will
    be 16 bits wide, plus the carry - the low-order bits are located
    in the effective address, and the high order bits are located in
    the effective address plus one.<br>
</p><pre>
    Flags affected: n-----zc
                    n Set if most significant bit of result is set.
                    z Set if result is zero.
                    c Low bit becomes the new carry.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Accumulator                  ROR a          6A      1       2 |
  Absolute                     ROR addr       6E      3       6 | 1
  Direct Page                  ROR dp         66      2       5 | 1,2
  Absolute Indexed,X           ROR addr,X     7E      3       7 | 1
  Direct Page Indexed,X        ROR dp,X       76      2       6 | 1,2
----------------------------------------------------------------------
   1 Add 2 cycles if 16 bit memory accumulator mode (m=0).
   2 Add 1 cycle if direct page pointer is &lt;&gt;0.



<b>RTI Return from Interrupt</b>
</pre><p>
    While in 6502 emulation mode (e=1) RTI is handled the same as a
    stock 6502.<br>
    While in native 65816 mode (e=0) RTI also pulls the program bank
    register byte off of the stack.  Since this extra byte is
    present, it is essential that the RTI be executed in the same
    mode (e=?) that the processor was in when the interrupt was
    executed.<br>
</p><pre>
    Flags Affected:  The status register is pulled from the stack,
                     therefore all flags are affected.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Stack (RTI)                  RTI            40      1       6 |  1
----------------------------------------------------------------------
  1 add 1 cycle if 65816 native mode.



<b>RTL Return from Subroutine Long</b>
</pre><p>
    RTL works similar to an RTS but it also pulls the program bank
    register off of the stack.  This instruction should be used
    in conjunction with the JSR long instruction or by a setup
    routine that also pushes the program bank onto the stack.
    RTL pulls 24 bits off of the stack.  First the two bytes of the
    program counter low/high are pulled and incremented, then the
    program bank register is pulled.<br>
</p> <p>
    No Flags are affected by RTL.<br>
<br><a href="#contents">TOC</a><br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (RTL)                  RTL            6B      1       6
----------------------------------------------------------------------



<b>RTS Return from Subroutine</b>
</pre>
    Same as the 6502 instruction.  No flags are affected.<br>
<p>
    One interesting use of RTS is to push a return address on the
    stack and then execute it via RTS.  In order to use this type of
    coding the address pushed onto the stack must be one less than
    the actual routine address because when pulled back off, the
    processor automatically inc's the program counter before
    continuing.  While in Native mode with 16 bit accumulator/memory
    set, this can easily be accomplished by:<br>
</p>
<pre>
          DEC A   ; dec 16 be accum. or DEA.
          PHA     ; push 16 bit return adr on stack.
          RTS     ; return to execute the instruction.


Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Stack (RTS)                  RTS            60      1       6
----------------------------------------------------------------------


</pre>
<b>SBC Subtract from Accumulator</b>
<p>
    SBC also works just a a 6502.  Again the only difference is a
    few new addressing modes, and the fact that data maybe worked in
    a 16 bit accumulator or 16 bit memory location.<br>
    SBC and ADC when used in 16 bit memory/accumulator mode greatly
    enhance the overall utility of the 65816.  A programmer can
    easily see how much faster addition and subtraction routines
    could be performed while operating on 16 bits instead of 8.<br>
</p>
<pre>
     Flags Altered nv----zc
                   n Set if most-significant bit of result is set.
                   v Set if signed overflow.
                   z Set if result is zero.
                   c Set if unsigned borrow not required.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Immediate                    SBC #const     E9      2*      2 | 1
  Absolute                     SBC addr       ED      3       4 | 1
  Absolute Long                SBC long       EF      4       5 | 1
  Direct Page                  SBC dp         E5      2       3 | 1,2
  Direct Page Indirect         SBC (dp)       F2      2       5 | 1,2
  Direct Page Indirect Long    SBC [dp]       E7      2       6 | 1,2
  Absolute Indexed,X           SBC addr,X     FD      3       4 | 1,3
  Absolute Long Indexed,X      SBC long,X     FF      4       5 | 1
  Absolute Indexed,Y           SBC addr,Y     F9      3       4 | 1,3
  Direct Page Indexed,X        SBC dp,X       F5      2       4 | 1,2
  DP Indexed Indirect,X        SBC (dp,X)     E1      2       6 | 1,2
  DP Indirect Indexed,Y        SBC (dp),Y     F1      2       5 | 1,2,3
  DP Indirect Long Indexed,Y   SBC [dp],Y     F7      2       6 | 1,2
  Stack Relative (SR)          SBC sr,S       E3      2       4 | 1
  SR Indirect Indexed,Y        SBC (sr,S),Y   F3      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.
   3 Add 1 cycle if adding index crosses a page boundary.



<b>SEP Set Status Bits</b>
</pre><p>
    SEP is a new 65816 instruction.  When used, it will set
    the bits specified by the 1 byte immediate value.<br>
    This is the only means of setting the M and X status register bits.<br>
</p><pre>
    For Example to set bit 5 of the status register:

       SEP #%00100000   ;set bit 5.

       or to clear multiple bits:

       SEP #%10110000   ;set bits 7,5 and 4.

    Any combination is acceptable.

    To reset a bit, see REP.

    Flags affected: nvmxdizc
                 All flags that have an operand bit set are set.
                 Other flags are not affected.


Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Immediate                 SEP #const       E2      2       3
----------------------------------------------------------------------



Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STA addr       8D      3       4 | 1
  Absolute Long                STA long       8F      4       5 | 1
  Direct Page                  STA dp         85      2       3 | 1,2
  Direct Page Indirect         STA (dp)       92      2       5 | 1,2
  Direct Page Indirect Long    STA [dp]       87      2       6 | 1,2
  Absolute Indexed,X           STA addr,X     9D      3       5 | 1
  Absolute Long Indexed,X      STA long,X     9F      4       5 | 1
  Absolute Indexed,Y           STA addr,Y     99      3       5 | 1
  Direct Page Indexed,X        STA dp,X       95      2       4 | 1,2
  DP Indexed Indirect,X        STA (dp,X)     81      2       6 | 1,2
  DP Indirect Indexed,Y        STA (dp),Y     91      2       6 | 1,2
  DP Indirect Long Indexed,Y   STA [dp],Y     97      2       6 | 1,2
  Stack Relative (SR)          STA sr,S       83      2       4 | 1
  SR Indirect Indexed,Y        STA (sr,S),Y   93      2       7 | 1
----------------------------------------------------------------------
   * Add 1 byte if m=0 (16-bit memory/accumulator).
   1 Add 1 cycle if m=0 (16-bit memory/accumulator).
   2 Add 1 cycle if low byte of Direct Page register is &lt;&gt;0.


<b>STP Stop the Processor</b>
</pre><p>
    STP shuts the processor down until a hardware reset.  It is used
    in some systems to put the processor to sleep and reduce power
    consumption.  There is a RESet B pin on some 65816 processors
    that allow for the usage of this instruction.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      STP            DB      1       3
----------------------------------------------------------------------



<b>STX Store X Register to Memory</b>
</pre><p>
    Another the same as 6502 mode.<br>
    Only exception is that when set for 16 bit index registers (x=0)
    data stored will be 16 bits wide.  Low 8 bits of Y will be
    stored to the effective address and the high byte to the
    effective address plus one.<br>
    No flags are affected by STX.<br>
<pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STX addr       8E      3       4 | 1
  Direct Page                  STX dp         86      2       3 | 1,2
  Direct Page Indexed,Y        STX dp,y       96      2       4 | 1,2
----------------------------------------------------------------------
  1 Add 1 cycle if 16 bit index registers (x=0)
  2 Add 1 more cycle if low byte of Direct Page is &lt;&gt;0.


<b>STY Store Y Register to Memory</b>
</pre><p>
    Same as 6502 mode.<br>
    Only exception is that when set for 16 bit index registers (x=0)
    data stored will be 16 bits wide.  Low 8 bits of Y will be
    stored to the effective address and the high byte to the
    effective address plus one.<br>
    No flags are affected by STY.<br>
</p>
<pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STY addr       8C      3       4 | 1
  Direct Page                  STY dp         84      2       3 | 1,2
  Direct Page Indexed,X        STY dp,X       94      2       4 | 1,2
----------------------------------------------------------------------
  1 Add 1 cycle if 16 bit index registers (x=0)
  2 Add 1 more cycle if low byte of Direct Page is &lt;&gt;0.



<b>STZ Store Zero byte to Memory</b>
</pre><p>
    A new instruction of the 65816.  STZ stores a zero byte to the
    destination address.  When in 8 bit accumulator/memory mode
    (m=1) one byte is stored at the effective address.  While in 16
    bit memory/accumulator mode (m=0) a zero is stored to the
    effective address and to the effective address plus one.  No
    flags are affected.<br>
</p> <p>
    This instruction could be defined as a replacement for stock
    6502 code as:<br>
</p><pre>
       lda #0
       sta $xxxx
</pre><p>
    The perky thing about STZ is that the accumulator is unchanged
    and the status register is also unchanged.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     STZ addr       9C      3       4 | 1
  Direct Page                  STZ dp         64      2       3 | 1,2
  Absolute Indexed,X           STZ addr,X     9E      3       5 | 1
  Direct Page Indexed,X        STZ dp,X       74      2       4 | 1,2
----------------------------------------------------------------------
   1 Add 1 cycle if 16 bit index registers (x=0)
   2 Add 1 more cycle if low byte of Direct Page is &lt;&gt;0.
<br>


<b>Register Transfer Instructions:</b>
</pre><p>
   TAX,TXA,TAY,TYA,TSX,TXS transfer instructions transfer bytes
   between the processor registers.<br>
</p><pre><p>
     <b>TAX:</b> Transfer accumulator to X index register.
     <b>TAY:</b> Transfer accumulator to Y index register.
     <b>TYA:</b> Transfer Y index register to the accumulator.
     <b>TXA:</b> Transfer X index register to the accumulator.
     <b>TSX:</b> Transfer Stack pointer to the X index register.
     <b>TXS:</b> Transfer X index register to the Stack pointer.
</pre><p>
   Two new register transfer instructions are TXY to transfer
   directly from the X register into the Y register and TYX to
   transfer from Y register to X register.<br>
</p> <p>
   Because the accumulator and index registers can be set for either
   8 or 16 bits independently, the width of the transfer is
   determined by the destination register.  The following table
   shows the possible combinations:<br>
</p><pre>
   8 bit acc to  8 bit index regs. (m=1,x=1) 8 bits transferred.
   8 bit acc,to 16 bit index regs (m=1, x=0), 16 bits are transferred.
                The hidden high order accumulator byte becomes the
                X or Y high byte.
  16 bit index regs to 8 bit acc (m=1, x=0), 8 bits are transferred.
                The hidden high order accumulator byte is not
                affected and the previous values remain.
   8 bit index regs to 16 bit acc (m=0, x=1), Two bytes
                transferred with the high byte being zero.
  16 bit acc to 8 bit index regs (m=0, x=1),  Only the low byte of the
                accumulator is transferred to the index register.
  16 bit acc to 16 bit index regs (m=0, x=0) 16 bits transferred.

  16 bit stack pointer to 8 bit X register.  Only the low byte
                address is transferred.
   8 bit X reg to 16 bit stack pointer, sets stack high byte to zero.


      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TAX            AA      1       2
  Implied                      TAY            A8      1       2
  Implied                      TXA            8A      1       2
  Implied                      TYA            98      1       2
  Implied                      TSX            BA      1       2
  Implied                      TXS            9A      1       2
  Implied                      TXY            9B      1       2
  Implied                      TYX            BB      1       2
----------------------------------------------------------------------



<b>Direct Page Instructions:</b>
<b>=========================</b>
</pre><p>
    Two new 65816 instructions are used to exchange data between
    the accumulator and the Direct Page Register.
</p><pre>
TCD Transfer Accumulator to Direct Page Register.
TDC Transfer Direct Page Register to Accumulator.
</pre><p>
    TCD transfers a 16 bit value from the accumulator into the
    direct (zero page) pointer.  A full 16 bits is transferred
    regardless of the 16/8 bit setting (m) of the accumulator.<br>
    The C in TCD is used to specify that the accumulator is
    referenced as C when it is 16 bits wide (low byte being A and
    high byte being B).<br>
    TDC transfers from the Direct Page register into the full
    16 bit accumulator without regard for the setting of status
    bit m.<br>
<br></p> <p>
    Some assemblers also allow TAD or TDA for the mnemonics.<br>
</p><pre>
      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TCD            5B      1       2
                        Alais: TAD
  Implied                      TDC            7B      1       2
                        Alais: TDA
----------------------------------------------------------------------



<b>TCS Transfer Accumulator to Stack Pointer</b>
</pre><p>
    TCS transfers a full 16 bits to the stack pointer without
    regard for the setting of status bit m.<br>
    As with TCD and TDC the C in TCS refers to the accumulator
    as a full 16 bits.<br>
    The mnemonic TAS, transfer a to stack pointer, is used by some
    assemblers.<br>
    While in 6502 emulation mode only the eight-bit A accumulator
    value is transferred because the stack is always located at page
    1 on a 6502 TCS and TXS are the only two instructions that alter
    the stack pointer register.<br>
</p> <p>
    No flags are affected by TCS.<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TCS            1B      1       2
                        Alais: TAS
----------------------------------------------------------------------


<b>TSC Transfer Stack Pointer to Accumulator</b>
</pre><p>
    TSC transfers a full 16 bits of the stack pointer to the 16 bit
    accumulator without regard for the setting of status bit m.<br>
    As with TCD and TDC the C in TSC refers to the accumulator as a
    full 16 bits.<br>
    The mnemonic TSA, transfer a to stack pointer, is used by some
    assemblers.<br>
</p> <p>
    While in 6502 emulation mode a one will be transferred to the
    hidden B (upper 8 bits) accumulator because the stack is always
    located at page one in 6502 mode.<br>
</p><pre>
      Flags Affected: n-----z-
                      n Set if most significant bit of transfer value
                        is set.
                      z Set if transferred value is zero.



Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      TSC            3B      1      2
                        Alais: TSA
----------------------------------------------------------------------



<b>TRB Test and Reset Memory Bits</b>
------------------------------
</pre>
<p>
TRB performs a logical AND of the accumulator's compliment and
the effective address - data is then rewritten back to the
specified address.  This clears each memory bit that has a
corresponding bit set in the accumulator, leaving all other
memory bits unchanged.<br>
</p> <p>
To put it another way - TRB flips or inverts the accumulator
value and then AND's that value with memory operand and stores
the result back to the effective address.<br>
</p> <p>
While is 16 bit accumulator mode (m=0) data is operated on
in the expected 16 bit fashion.  The low byte of the operation
is at the effective address and the high byte at the effective
address plus one.<br>
</p><pre>
       Flags Affected: ------z-
                       z Set if memory value AND'ed with accumulator
                       value is zero.

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     TRB addr       1C      3       6 | 1
  Direct Page                  TRB dp         14      2       5 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if 16 bit memory/accumulator mode (m=0)
    2 Add 1 cycle if direct page register low byte is &lt;&gt;0.



<b>TSB Test and Set Memory Bits</b>
----------------------------
</pre><p>
    TSB logically OR's the accumulator and the data at the effective
    address.  This effectively sets a bit at the memory location for
    each bit set in the accumulator.<br>
</p> <p>
    While is 16 bit accumulator mode (m=0) data is operated on in
    the expected 16 bit fashion.  The low byte of the operation is
    at the effective address and the high byte at the effective
    address plus one.<br>
</p> <p>
    The status register zero flag is set after the accumulator is
    AND'd with the memory value.  (same as the BIT instruction).<br>
</p><pre>
       Flags Affected: ------z-
                       z Set if memory value AND'ed with accumulator
                       value is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
  Absolute                     TSB addr       0C      3       6 | 1
  Direct Page                  TSB dp         04      2       5 | 1,2
----------------------------------------------------------------------
    1 Add 2 cycles if 16 bit memory/accumulator mode (m=0)
    2 Add 1 cycle if direct page register low byte is &lt;&gt;0.



<b>WAI Wait for Interrupt</b>
----------------------
</pre>
<p>
WAI suspends operations until and external hardware interrupt is
generated.  Power consumption by the processor is also reduced.
If the disable interrupt flag (i=1) is set and an IRQ is pending
before the execution of the WAI, then the WAIT is terminated and
execution continues with the next instruction.<br>
</p> <p>
    No flags are affected by WAI.<br><br>
</p>
<pre>
Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      WAI            CB      1       3
----------------------------------------------------------------------



<b>WDM Reserved for Future Expansion</b>
---------------------------------
</pre><p>
    WDM is the first byte of a multi-byte instruction set to be used
    in future versions of the processor.<br>
    At current WDM is treated like a NOP no operation.<br>
    This instruction should NOT be used in current versions of the
    processor.<br>
    WDM: William D. Mensch, JR. (65816 designer).<br>
</p><pre>

Addressing Mode              Syntax        Opcode   Bytes  Cycles Ref
----------------------------------------------------------------------
                               WDM            42      2
----------------------------------------------------------------------



<b>XBA Exchange B and A Accumulators</b>
---------------------------------
</pre>
<p>
    XBA exchanges the low eight bits of the accumulator (A) with the
    high order 8 bits of the accumulator (B).  This operation has no
    regard for the setting of the status bit M.<br>
    This instruction will also work in 6502 emulation mode.<br>
</p> <p>
    XBA can be used to save a temp copy of the low accumulator in
    the upper accumulator.  It is also good when in 16 bit mode to
    invert a low and high byte value.<br>
</p> <p>
    XBA is the only instruction that can access the upper 8 bits of
    the accumulator in emulation mode.<br>
</p> <p>
    Some assemblers will also accept SWA (swap) for a mnemonic.<br>
</p><pre>
      Flags Affected: n------z-
                      n Set if the most significant bit of the new
                        value in the low order 8 bits (A) of the
                        accumulator is set. (former bit 15)
                      z Set if new value of the lower order 8 bit
                        accumulator (A) is zero.


Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      XBA            EB      1       3
                        Alais: SWA
----------------------------------------------------------------------



<b>XCE Exchange Carry and Emulation Bits</b>
-------------------------------------
</pre><p>
    XCE exchanges (swaps) the value in the E emulation bit and the C
    carry flag.  This is the only means to access the E emulation
    bit.<br>
</p>
<pre>
<b>    To set emulation mode:</b>
            sec  ;set carry.
            xce  ;exchange carry and emulation bits.

<b>    To set native mode:</b>
            clc  ;clear carry
            xce  ;exchange carry and e bit.

                            e
    Flags Affected --mx/b---c
                   e from previous carry flag.
                   c from previous emulation flag.
                   m native mode flag only. switching to native
                     65816 mode sets to one.
                   x x is a native mode flag only.
                   b brk is an emulation 6502 flag only. it is set
                     to 1 to become the x flag in native mode

Addressing Mode              Syntax        Opcode   Bytes  Cycles
----------------------------------------------------------------------
  Implied                      XCE            FB      1       2
----------------------------------------------------------------------

<br><a href="#contents">TOC</a><br>

<hr>
<a name="appenb"><h1>Appendix B:Composite Instruction List</h1></a>
<hr>
<hr>


<b>Opcode Mnemonic  Addressing Mode              Bytes Cycles| Reference</b>
=====================================================================
   00      BRK     Stack/Interrupt                2**     7 | 9
   01      ORA     DP Indexed Indirect,X          2       6 | 1,2
   02      COP     Stack/Interrupt                2**     7 | 9
   03      ORA     Stack Relative                 2       4 | 1
   04      TSB     Direct Page                    2       5 | 2,5
   05      ORA     Direct Page                    2       3 | 1,2
   06      ASL     Direct Page                    2       5 | 2,5
   07      ORA     Direct Page Indirect Long      2       6 | 1,2
   08      PHP     Stack (Push)                   1       3 |
   09      ORA     Immediate                      2*      2 | 1
   0A      ASL     Accumulator                    1       2 |
   0B      PHD     Stack (Push)                   1       4 |
   0C      TSB     Absolute                       3       6 | 5
   0D      ORA     Absolute                       3       4 | 1
   0E      ASL     Absolute                       3       6 | 5
   0F      ORA     Absolute Long                  4       5 | 1
   10      BPL     Program Counter Relative       2       2 | 7,8
   11      ORA     DP Indirect Indexed,Y          2       5 | 1,2,3
   12      ORA     Direct Page Indirect           2       5 | 1,2
   13      ORA     SR Indirect Indexed,Y          2       7 | 1
   14      TRB     Direct Page                    2       5 | 2,5
   15      ORA     Direct Page Indexed,X          2       4 | 1,2
   16      ASL     Direct Page Indexed,X          2       6 | 2,5
   17      ORA     DP Indirect Long Indexed,Y     2       6 | 1,2
   18      CLC     Implied                        1       2 |
   19      ORA     Absolute Indexed,Y             3       4 | 1,3
   1A      INC     Accumulator (INA)              1       2 |
   1B      TCS     Implied                        1       2 |
   1C      TRB     Absolute                       3       6 | 5
   1D      ORA     Absolute Indexed,X             3       4 | 1,3
   1E      ASL     Absolute Indexed,X             3       7 | 5,6
   1F      ORA     Absolute Long Indexed,X        4       5 | 1
   20      JSR     Absolute                       3       6 |
   21      AND     DP Indexed Indirect,X          2       6 | 1,2
   22      JSR     Absolute Long                  4       8 |
   23      AND     Stack Relative                 2       4 | 1
   24      BIT     Direct Page                    2       3 | 1,2
   25      AND     Direct Page                    2       3 | 1,2
   26      ROL     Direct Page                    2       5 | 2,5
   27      AND     Direct Page Indirect Long      2       6 | 1,2
   28      PLP     Stack (Pull)                   1       4 |
   29      AND     Immediate                      2*      2 | 1
   2A      ROL     Accumulator                    1       2 |
   2B      PLD     Stack (Pull)                   1       5 |
   2C      BIT     Absolute                       3       4 | 1
   2D      AND     Absolute                       3       4 | 1
   2E      ROL     Absolute                       3       6 | 5
   2F      AND     Absolute Long                  4       5 | 1
   30      BMI     Program Counter Relative       2       2 | 7,8
   31      AND     DP Indirect Indexed,Y          2       5 | 1,2,3
   32      AND     Direct Page Indirect           2       5 | 1,1
   33      AND     SR Indirect Indexed,Y          2       7 | 1
   34      BIT     Direct Page Indexed,X          2       4 | 1,2
   35      AND     Direct Page Indexed,X          2       4 | 1,2
   36      ROL     Direct Page Indexed,X          2       6 | 2,5
   37      AND     DP Indirect Long Indexed,Y     2       6 | 1,2
   38      SEC     Implied                        1       2 |
   39      AND     Absolute Indexed,Y             3       4 | 1,3
   3A      DEC     Accumulator                    1       2 |
   3B      TSC     Implied                        1       2 |
   3C      BIT     Absolute Indexed,X             3       4 | 1,3
   3D      AND     Absolute Indexed,X             3       4 | 1,3
   3E      ROL     Absolute Indexed,X             3       7 | 5,6
   3F      AND     Absolute Long Indexed,X        4       5 | 1
   40      RTI     Stack/RTI                      1       6 | 9
   41      EOR     DP Indexed Indirect,X          2       6 | 1,2
   42      WDM                                    2|16      |
   43      EOR     Stack Relative                 2       4 | 1
   44      MVP     Block Move                     3         | 13
   45      EOR     Direct Page                    2       3 | 1,2
   46      LSR     Direct Page                    2       5 | 2,5
   47      EOR     Direct Page Indirect Long      2       6 | 1,2
   48      PHA     Stack (Push)                   1       3 | 1
   49      EOR     Immediate                      2*      2 | 1
   4A      LSR     Accumulator                    1       2 |
   4B      PHK     Stack (Push)                   1       3 |
   4C      JMP     Absolute                       3       3 |
   4D      EOR     Absolute                       3       4 | 1
   4E      LSR     Absolute                       3       6 | 5
   4F      EOR     Absolute Long                  4       5 | 1
   50      BVC     Program Counter Relative       2       2 | 7,8
   51      EOR     DP Indirect Indexed,Y          2       5 | 1,2,3
   52      EOR     Direct Page Indirect           2       5 | 1,2
   53      EOR     SR Indirect Indexed,Y          2       7 | 1
   54      MVN     Block Move                     3         | 13
   55      EOR     Direct Page Indexed,X          2       4 | 1,2
   56      LSR     Direct Page Indexed,X          2       6 | 2,5
   57      EOR     DP Indirect Long Indexed,Y     2       6 | 1,2
   58      CLI     Implied                        1       2 |
   59      EOR     Absolute Indexed,Y             3       4 | 1,3
   5A      PHY     Stack (Push)                   1       3 | 10
   5B      TCD     Implied                        1       2 |
   5C      JMP     Absolute Long                  4       4 |
   5D      EOR     Absolute Indexed,X             3       4 | 1,3
   5E      LSR     Absolute Indexed,X             3       7 | 5,6
   5F      EOR     Absolute Long Indexed,X        4       5 | 1
   60      RTS     Stack (RTS)                    1       6 |
   61      ADC     DP Indexed Indirect,X          2       6 | 1,2,4
   62      PER     Stack (PC Relative Long)       3       6 |
   63      ADC     Stack Relative                 2       4 | 1,4
   64      STZ     Direct Page                    2       3 | 1,2
   65      ADC     Direct Page                    2       3 | 1,2,4
   66      ROR     Direct Page                    2       5 | 1
   67      ADC     Direct Page Indirect Long      2       6 | 1,4
   68      PLA     Stack (Pull)                   1       4 | 1
   69      ADC     Immediate                      2*      2 | 1,4
   6A      ROR     Accumulator                    1       2 |
   6B      RTL     Stack (RTL)                    1       6 |
   6C      JMP     Absolute Indirect              3       5 | 11,12
   6D      ADC     Absolute                       3       4 | 1,4
   6E      ROR     Absolute                       3       6 | 5
   6F      ADC     Absolute Long                  4       5 | 1,4
   70      BVS     Program Counter Relative       2       2 | 7,8
   71      ADC     DP Indirect Indexed,Y          2       5 | 1,2,3,4
   72      ADC     Direct Page Indirect           2       5 | 1,2,4
   73      ADC     SR Indirect Indexed,Y          2       7 | 1,4
   74      STZ     Direct Page Indexed,X          2       4 | 1,2
   75      ADC     Direct Page Indexed,X          2       4 | 1,2,4
   76      ROR     Direct Page Indexed,X          2       6 | 2,5
   77      ADC     DP Indirect Long Indexed,Y     2       6 | 1,2,4
   78      SEI     Implied                        1       2 |
   79      ADC     Absolute Indexed,Y             3       4 | 1,3,4
   7A      PLY     Stack (Pull)                   1       4 | 10
   7B      TDC     Implied                        1       2 |
   7C      JMP     Absolute Indexed Indirect      3       6 |
   7D      ADC     Absolute Indexed,X             3       4 | 1,3,4
   7E      ROR     Absolute Indexed,X             3       7 | 5,6
   7F      ADC     Absolute Long Indexed,X        4       5 | 1,4
   80      BRA     Program Counter Relative       2       3 | 8
   81      STA     DP Indexed Indirect,X          2       6 | 1,2
   82      BRL     Program Counter Relative Long  3       4 |
   83      STA     Stack Relative                 2       4 | 1
   84      STY     Direct Page                    2       3 | 2,10
   85      STA     Direct Page                    2       3 | 1,2
   86      STX     Direct Page                    2       3 | 2,10
   87      STA     Direct Page Indirect Long      2       6 | 1,2
   88      DEY     Implied                        1       2 |
   89      BIT     Immediate                      2*      2 | 1
   8A      TXA     Implied                        1       2 |
   8B      PHB     Stack (Push)                   1       3 |
   8C      STY     Absolute                       3       4 | 10
   8D      STA     Absolute                       3       4 | 1
   8E      STX     Absolute                       3       4 | 10
   8F      STA     Absolute Long                  4       5 | 1
   90      BCC     Program Counter Relative       2       2 | 7,8
   91      STA     DP Indirect Indexed,Y          2       6 | 1,2
   92      STA     Direct Page Indirect           2       5 | 1,2
   93      STA     SR Indirect Indexed,Y          2       7 | 1
   94      STY     Direct Page Indexed,X          2       4 | 2,10
   95      STA     Direct Page Indexed,X          2       4 | 1,2
   96      STX     Direct Page Indexed,Y          2       4 | 2,10
   97      STA     DP Indirect Long Indexed,Y     2       6 | 1,2
   98      TYA     Implied                        1       2 |
   99      STA     Absolute Indexed,Y             3       5 | 1
   9A      TXS     Implied                        1       2 |
   9B      TXY     Implied                        1       2 |
   9C      STZ     Absolute                       3       4 | 1
   9D      STA     Absolute Indexed,X             3       5 | 1
   9E      STZ     Absolute Indexed,X             3       5 | 1
   9F      STA     Absolute Long Indexed,X        4       5 | 1
   A0      LDY     Immediate                      2+      2 | 10
   A1      LDA     DP Indexed Indirect,X          2       6 | 1,2
   A2      LDX     Immediate                      2+      2 | 10
   A3      LDA     Stack Relative                 2       4 | 1
   A4      LDY     Direct Page                    2       3 | 2,10
   A5      LDA     Direct Page                    2       3 | 1,2
   A6      LDX     Direct Page                    2       3 | 2,10
   A7      LDA     Direct Page Indirect Long      2       6 | 1,2
   A8      TAY     Implied                        1       2 |
   A9      LDA     Immediate                      2*      2 | 1
   AA      TAX     Implied                        1       2 |
   AB      PLB     Stack (Pull)                   1       4 |
   AC      LDY     Absolute                       3       4 | 10
   AD      LDA     Absolute                       3       4 | 1
   AE      LDX     Absolute                       3       4 | 10
   AF      LDA     Absolute Long                  4       5 | 1
   B0      BCS     Program Counter Relative       2       2 | 7,8
   B1      LDA     DP Indirect Indexed,Y          2       5 | 1,2,3
   B2      LDA     Direct Page Indirect           2       5 | 1,2
   B3      LDA     SR Indirect Indexed,Y          2       7 | 1
   B4      LDY     Direct Page Indexed,X          2       4 | 2,10
   B5      LDA     Direct Page Indexed,X          2       4 | 1,2
   B6      LDX     DP Indexed,Y                   2       4 | 2,10
   B7      LDA     DP Indirect Long Indexed,Y     2       6 | 1,2
   B8      CLV     Implied                        1       2 |
   B9      LDA     Absolute Indexed,Y             3       4 | 1,3
   BA      TSX     Implied                        1       2 |
   BB      TYX     Implied                        1       2 |
   BC      LDY     Absolute Indexed,X             3       4 | 3,10
   BD      LDA     Absolute Indexed,X             3       4 | 1,3
   BE      LDX     Absolute Indexed,Y             3       4 | 3,10
   BF      LDA     Absolute Long Indexed,X        4       5 | 1
   C0      CPY     Immediate                      2+      2 | 10
   C1      CMP     DP Indexed Indirect,X          2       6 | 1,2
   C2      REP     Immediate                      2       3 |
   C3      CMP     Stack Relative                 2       4 | 1
   C4      CPY     Direct Page                    2       3 | 2,10
   C5      CMP     Direct Page                    2       3 | 1,2
   C6      DEC     Direct Page                    2       5 | 2,5
   C7      CMP     Direct Page Indirect Long      2       6 | 1,2
   C8      INY     Implied                        1       2 |
   C9      CMP     Immediate                      2*      2 | 1
   CA      DEX     Implied                        1       2 |
   CB      WAI     Implied                        1       3 | 15
   CC      CPY     Absolute                       3       4 | 10
   CD      CMP     Absolute                       3       4 | 1
   CE      DEC     Absolute                       3       6 | 5
   CF      CMP     Absolute Long                  4       5 | 1
   D0      BNE     Program Counter Relative       2       2 | 7,8
   D1      CMP     DP Indirect Indexed,Y          2       5 | 1,2,3
   D2      CMP     Direct Page Indirect           2       5 | 1,2
   D3      CMP     SR Indirect Indexed,Y          2       7 | 1
   D4      PEI     Stack (Direct Page Indirect)   2       6 | 2
   D5      CMP     Direct Page Indexed,X          2       4 | 1,2
   D6      DEC     Direct Page Indexed,X          2       6 | 2,5
   D7      CMP     DP Indirect Long Indexed,Y     2       6 | 1,2
   D8      CLD     Implied                        1       2 |
   D9      CMP     Absolute Indexed,Y             3       4 | 1,3
   DA      PHX     Stack (Push)                   1       3 | 10
   DB      STP     Implied                        1       3 | 14
   DC      JMP     Absolute Indirect Long         3       6 |
   DD      CMP     Absolute Indexed,X             3       4 | 1,3
   DE      DEC     Absolute Indexed,X             3       7 | 5,6
   DF      CMP     Absolute Long Indexed,X        4       5 | 1
   E0      CPX     Immediate                      2+      2 | 10
   E1      SBC     DP Indexed Indirect,X          2       6 | 1,2,4
   E2      SEP     Immediate                      2       3 |
   E3      SBC     Stack Relative                 2       4 | 1,4
   E4      CPX     Direct Page                    2       3 | 2,10
   E5      SBC     Direct Page                    2       3 | 1,2,4
   E6      INC     Direct Page                    2       5 |
   E7      SBC     Direct Page Indirect Long      2       6 | 1,2,4
   E8      INX     Implied                        1       2 |
   E9      SBC     Immediate                      2*      2 |
   EA      NOP     Implied                        1       2 |
   EB      XBA     Implied                        1       3 |
   EC      CPX     Absolute                       3       4 | 10
   ED      SBC     Absolute                       3       4 | 1,4
   EE      INC     Absolute                       3       6 | 5
   EF      SBC     Absolute Long                  4       5 | 1,4
   F0      BEQ     Program Counter Relative       2       2 | 7,8
   F1      SBC     DP Indirect Indexed,Y          2       5 | 1,2,3,4
   F2      SBC     Direct Page Indirect           2       5 | 1,2,4
   F3      SBC     SR Indirect Indexed,Y          2       7 | 1,4
   F4      PEA     Stack (Absolute)               3       5 |
   F5      SBC     Direct Page Indexed,X          2       4 | 1,2,4
   F6      INC     Direct Page Indexed,X          2       6 | 2,5
   F7      SBC     DP Indirect Long Indexed,Y     2       6 | 1,2,4
   F8      SED     Implied                        1       2 |
   F9      SBC     Absolute Indexed,Y             3       4 | 1,3,4
   FA      PLX     Stack (Pull)                   1       4 | 10
   FB      XCE     Implied                        1       2 |
   FC      JSR     Absolute Indexed Indirect      3       8 |
   FD      SBC     Absolute Indexed,X             3       4 | 1,3,4
   FE      INC     Absolute Indexed,X             3       7 | 5,6
   FF      SBC     Absolute Long Indexed,X        4       5 | 1,4
<b>=====================================================================</b>

*  Add 1 if m=0 (16 bit memory/accumulator).
** Opcode is 1 byte, but program counter value pushed onto stack is
   incremented by 2 allowing for optional signature byte.
+  Add 1 byte if x=0 (16-bit index registers).
1  Add 1 cycle if m=0 (16-bit memory/accumulator).
2  Add 1 cycle if low bye of Direct Page (zero page) register
   is other than zero (DL&lt;&gt;0).
3  Add 1 cycle if adding index crosses a page boundary.
4  Add 1 cycle if CPU is 65C02 and d=1 (decimal mode. 65C02 only).
5  Add 2 cycles if m=0 (16-bit memory/accumulator).
6  Subtract 1 cycle if CPU is 65C02 and no page boundary crossed.
7  Add 1 cycle if branch is taken.
8  Add 1 more cycle if branch taken crosses page boundary on 6502,
   65C02, or 65816/65082's emulation mode (e=1).
9  Add 1 cycle for 65802/65816 native mode (e=0).
10 Add 1 cycle if x=0 (16-bit index registers).
11 Add 1 cycle if CPU is 65C02.
12 6502: if low byte of operand is $FF (ie. operand is $xxFF): yields
   incorrect result.
13 7 cycles per byte moved.
14 Uses 3 cycles to shut the processor down; additional cycles are
   required by reset to restart CPU.
15 Uses 3 cycles to shut the processor down; additional cycles are
   required by interrupt to restart it.
16 Byte and cycle counts subject to change in future processors which
   expand WDM into 2-byte opcode portions of instructions of varying
   lengths.
<br>
<br><a href="#contents">TOC</a><br>

<hr>
<b>========================================================================</b>
<hr>
=====================
<a name="appenc"><b>Appendix C: IC Pinouts</b></a>
=====================

           /=============\                     /=============\
       VP  I1          40I RES            Vss  I1          40I RES
      RDY  I2          39I VDA            RDY  I2          39I o2 (OUT)
    ABORT  I3          38I M/X       o1 (OUT)  I3          38I SO
      IRQ  I4          37I o2 (IN)        IRQ  I4          37I o2 (IN)
       ML  I5          36I BE              NC  I5          36I NC
      NMI  I6          35I E              NMI  I6          35I NC
      VPA  I7          34I R/W           SYNC  I7          34I R/W
      VDD  I8          33I D0/BA0         Vdd  I8          33I D0
       A0  I9  W65C816 32I D1/BA1          A0  I9   6502   32I D1
       A1  I10         31I D2/BA2          A1  I10         31I D2
       A2  I11         30I D3/BA3          A2  I11         30I D3
       A3  I12         29I D4/BA4          A3  I12         29I D4
       A4  I13         28I D5/BA5          A4  I13         28I D5
       A5  I14         27I D6/BA6          A5  I14         27I D6
       A6  I15         26I D7/BA7          A6  I15         26I D7
       A7  I16         25I A15             A7  I16         25I A15
       A8  I17         24I A14             A8  I17         24I A14
       A9  I18         23I A13             A9  I18         23I A13
      A10  I19         22I A12            A10  I19         22I A12
      A11  I20         21I Vss            A11  I20         21I Vss
           \=============/                     \=============/

<b>Notes:</b>
   ML: Memory Lock line (pin 5) is asserted low during the execution of
       the read-modify-write (asl,dec,inc,lsr,rol,ror,trb, and tsb
       instructions to inform other ics that the bus may not be claimed
       yet.

   VP: Vector Pull is asserted whenever any of the hardware vector
       address's are being accessed during an IRQ.

 Abort:  An input.  When asserted caused the current instruction to be
         aborted.

   VPA/VDA.  Valid Program Address and Valid Data Address.  These two
             signals extend on the 6502 SYNC line - to better handle
             DMA schemes.

       VPA   VDA
        0     0  -Internal Operation
        0     1  -Valid program address
        1     0  -Valid data address
        1     1  -Opcode fetch


    M/X: Memory and Index lines.  These signals are multiplexed on pin
         38.  M is available during phase zero and X during Phase one.
         These two signals reflect the contents of the status register
         m and x flags, allowing other devices to decode opcode fetches.

    E: Emulation pin.  This signal reflects the state of the processors
       emulation bit (E).
<br>
<br><a href="#contents">TOC</a><br>
<hr>
<b>===================================================================</b>
<b>44 PIN PLCC Pinout.</b>

                    A
                    B
                    O               R           0
            M   I   R   R   V   V   E   V   M   2
            L   R   T   D   P   S   S   D   /   I   B
            B   Q   B   Y   B   S   B   A   X   N   E
           /----I---I---I---I---I---I---I---I---I---I-\
          / 6   5   4   3   2  1  44  43  42  41  40 I
    NMIB I 7                                       39 - E
     VPA I 8                                       38 - R/WB
     VDD I 9                                       37 - VDD
      A0 I 10                                      36 - D0/BA0
      A1 I 11                                      35 - D1/BA1
     VSS I 12               <b>W65C816S</b>               34 - D2/BA2
      A2 I 13                                      33 - D3/BA3
      A3 I 14                                      32 - D4/BA4
      A4 I 15                                      31 - D5/BA5
      A5 I 16                                      30 - D6/BA6
      A6 I 17                                      29 - D7/BA7
         I 18  19  20  21  22  23  24  25  26  27  28 I
         \--l---l---l---l---l---l---l---l---l---l---l-/
            A   A   A   A   A   V   V   A   A   A   A
            7   8   9   1   1   S   S   1   1   1   1
                        0   1   S   S   2   3   4   5

<b>                   44 pin W65C816S PLCC Pinout</b>
</p> <p>
<br><br><a href="#contents">TOC</a><br>
</p></pre></font>
<p>
<hr size=7 width=70% align=center>
<br>
<br>
</p>
</font>
<br clear=left>
Last updated on: Tuesday, 10-Feb-1998 22:50:03 CST
24
[an error occurred while processing this directive]
